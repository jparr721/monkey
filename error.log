{"message":"No repository for \"Keys\" was found. Looks like this entity is not registered in current \"default\" connection?","level":"error","service":"monkey"}
{"message":"No repository for \"Keys\" was found. Looks like this entity is not registered in current \"default\" connection?","level":"error","service":"monkey"}
{"message":"No repository for \"Keys\" was found. Looks like this entity is not registered in current \"default\" connection?","level":"error","service":"monkey"}
{"message":"No repository for \"Keys\" was found. Looks like this entity is not registered in current \"default\" connection?","level":"error","service":"monkey"}
{"message":"No repository for \"Keys\" was found. Looks like this entity is not registered in current \"default\" connection?","level":"error","service":"monkey"}
{"message":"No repository for \"Keys\" was found. Looks like this entity is not registered in current \"default\" connection?","level":"error","service":"monkey"}
{"message":"{\n  \"_readableState\": {\n    \"objectMode\": false,\n    \"highWaterMark\": 16384,\n    \"buffer\": {\n      \"head\": null,\n      \"tail\": null,\n      \"length\": 0\n    },\n    \"length\": 0,\n    \"pipes\": [],\n    \"flowing\": null,\n    \"ended\": false,\n    \"endEmitted\": false,\n    \"reading\": false,\n    \"sync\": true,\n    \"needReadable\": false,\n    \"emittedReadable\": false,\n    \"readableListening\": false,\n    \"resumeScheduled\": false,\n    \"errorEmitted\": false,\n    \"emitClose\": true,\n    \"autoDestroy\": false,\n    \"destroyed\": false,\n    \"errored\": null,\n    \"closed\": false,\n    \"closeEmitted\": false,\n    \"defaultEncoding\": \"utf8\",\n    \"awaitDrainWriters\": null,\n    \"multiAwaitDrain\": false,\n    \"readingMore\": true,\n    \"decoder\": null,\n    \"encoding\": null\n  },\n  \"_events\": {\n    \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n  },\n  \"_eventsCount\": 1,\n  \"socket\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": true,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.socket]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.socket]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.socket.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118370,\n          472086741\n        ],\n        \"_startTime\": \"2020-11-30T04:16:43.273Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.socket]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.socket._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118370,\n          472086741\n        ],\n        \"_startTime\": \"2020-11-30T04:16:43.273Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 33946\n    }\n  },\n  \"httpVersionMajor\": 1,\n  \"httpVersionMinor\": 1,\n  \"httpVersion\": \"1.1\",\n  \"complete\": false,\n  \"headers\": {\n    \"host\": \"localhost:3000\",\n    \"connection\": \"keep-alive\",\n    \"upgrade-insecure-requests\": \"1\",\n    \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n    \"sec-fetch-site\": \"none\",\n    \"sec-fetch-mode\": \"navigate\",\n    \"sec-fetch-user\": \"?1\",\n    \"sec-fetch-dest\": \"document\",\n    \"accept-encoding\": \"gzip, deflate, br\",\n    \"accept-language\": \"en-US,en;q=0.9\"\n  },\n  \"rawHeaders\": [\n    \"Host\",\n    \"localhost:3000\",\n    \"Connection\",\n    \"keep-alive\",\n    \"Upgrade-Insecure-Requests\",\n    \"1\",\n    \"User-Agent\",\n    \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"Accept\",\n    \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n    \"Sec-Fetch-Site\",\n    \"none\",\n    \"Sec-Fetch-Mode\",\n    \"navigate\",\n    \"Sec-Fetch-User\",\n    \"?1\",\n    \"Sec-Fetch-Dest\",\n    \"document\",\n    \"Accept-Encoding\",\n    \"gzip, deflate, br\",\n    \"Accept-Language\",\n    \"en-US,en;q=0.9\"\n  ],\n  \"trailers\": {},\n  \"rawTrailers\": [],\n  \"aborted\": false,\n  \"upgrade\": false,\n  \"url\": \"/\",\n  \"method\": \"GET\",\n  \"statusMessage\": null,\n  \"client\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": true,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.client]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.client]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.client.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118370,\n          472086741\n        ],\n        \"_startTime\": \"2020-11-30T04:16:43.273Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.client]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.client._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118370,\n          472086741\n        ],\n        \"_startTime\": \"2020-11-30T04:16:43.273Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 33946\n    }\n  },\n  \"_consuming\": false,\n  \"_dumped\": false,\n  \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n  \"baseUrl\": \"\",\n  \"originalUrl\": \"/\",\n  \"_parsedUrl\": {\n    \"protocol\": null,\n    \"slashes\": null,\n    \"auth\": null,\n    \"host\": null,\n    \"port\": null,\n    \"hostname\": null,\n    \"hash\": null,\n    \"search\": null,\n    \"query\": null,\n    \"pathname\": \"/\",\n    \"path\": \"/\",\n    \"href\": \"/\",\n    \"_raw\": \"/\"\n  },\n  \"params\": {},\n  \"query\": {},\n  \"res\": {\n    \"_events\": {\n      \"finish\": [\n        function () { [native code] },\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n    },\n    \"_eventsCount\": 2,\n    \"outputData\": [],\n    \"outputSize\": 0,\n    \"writable\": true,\n    \"destroyed\": false,\n    \"_last\": false,\n    \"chunkedEncoding\": false,\n    \"shouldKeepAlive\": true,\n    \"_defaultKeepAlive\": true,\n    \"useChunkedEncodingByDefault\": true,\n    \"sendDate\": true,\n    \"_removedConnection\": false,\n    \"_removedContLen\": false,\n    \"_removedTE\": false,\n    \"_contentLength\": null,\n    \"_hasBody\": true,\n    \"_trailer\": \"\",\n    \"finished\": false,\n    \"_headerSent\": false,\n    \"socket\": {\n      \"connecting\": false,\n      \"_hadError\": false,\n      \"_parent\": null,\n      \"_host\": null,\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": true,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": true,\n        \"sync\": false,\n        \"needReadable\": true,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": false,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": [\n          function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n          function () { [native code] }\n        ],\n        \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n        \"data\": function () { [native code] },\n        \"error\": [\n          function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"close\": [\n          function () { [native code] },\n          function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"drain\": function () { [native code] },\n        \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n        \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n      },\n      \"_eventsCount\": 8,\n      \"_writableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"finalCalled\": false,\n        \"needDrain\": false,\n        \"ending\": false,\n        \"ended\": false,\n        \"finished\": false,\n        \"destroyed\": false,\n        \"decodeStrings\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"length\": 0,\n        \"writing\": false,\n        \"corked\": 0,\n        \"sync\": true,\n        \"bufferProcessing\": false,\n        \"onwrite\": function () { [native code] },\n        \"writecb\": null,\n        \"writelen\": 0,\n        \"afterWriteTickInfo\": null,\n        \"buffered\": [],\n        \"bufferedIndex\": 0,\n        \"allBuffers\": true,\n        \"allNoop\": true,\n        \"pendingcb\": 0,\n        \"prefinished\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false\n      },\n      \"allowHalfOpen\": true,\n      \"_sockname\": null,\n      \"_pendingData\": null,\n      \"_pendingEncoding\": \"\",\n      \"server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"_server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"parser\": {\n        \"0\": function () { [native code] },\n        \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n        \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n        \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n        \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n        \"5\": function () { [native code] },\n        \"6\": function () { [native code] },\n        \"_headers\": [],\n        \"_url\": \"\",\n        \"socket\": \"[Circular ~.res.socket]\",\n        \"incoming\": {\n          \"_readableState\": {\n            \"objectMode\": false,\n            \"highWaterMark\": 16384,\n            \"buffer\": {\n              \"head\": null,\n              \"tail\": null,\n              \"length\": 0\n            },\n            \"length\": 0,\n            \"pipes\": [],\n            \"flowing\": null,\n            \"ended\": false,\n            \"endEmitted\": false,\n            \"reading\": false,\n            \"sync\": true,\n            \"needReadable\": false,\n            \"emittedReadable\": false,\n            \"readableListening\": false,\n            \"resumeScheduled\": false,\n            \"errorEmitted\": false,\n            \"emitClose\": true,\n            \"autoDestroy\": false,\n            \"destroyed\": false,\n            \"errored\": null,\n            \"closed\": false,\n            \"closeEmitted\": false,\n            \"defaultEncoding\": \"utf8\",\n            \"awaitDrainWriters\": null,\n            \"multiAwaitDrain\": false,\n            \"readingMore\": true,\n            \"decoder\": null,\n            \"encoding\": null\n          },\n          \"_events\": {\n            \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n          },\n          \"_eventsCount\": 1,\n          \"socket\": \"[Circular ~.res.socket]\",\n          \"httpVersionMajor\": 1,\n          \"httpVersionMinor\": 1,\n          \"httpVersion\": \"1.1\",\n          \"complete\": false,\n          \"headers\": {\n            \"host\": \"localhost:3000\",\n            \"connection\": \"keep-alive\",\n            \"upgrade-insecure-requests\": \"1\",\n            \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n            \"sec-fetch-site\": \"none\",\n            \"sec-fetch-mode\": \"navigate\",\n            \"sec-fetch-user\": \"?1\",\n            \"sec-fetch-dest\": \"document\",\n            \"accept-encoding\": \"gzip, deflate, br\",\n            \"accept-language\": \"en-US,en;q=0.9\"\n          },\n          \"rawHeaders\": [\n            \"Host\",\n            \"localhost:3000\",\n            \"Connection\",\n            \"keep-alive\",\n            \"Upgrade-Insecure-Requests\",\n            \"1\",\n            \"User-Agent\",\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"Accept\",\n            \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n            \"Sec-Fetch-Site\",\n            \"none\",\n            \"Sec-Fetch-Mode\",\n            \"navigate\",\n            \"Sec-Fetch-User\",\n            \"?1\",\n            \"Sec-Fetch-Dest\",\n            \"document\",\n            \"Accept-Encoding\",\n            \"gzip, deflate, br\",\n            \"Accept-Language\",\n            \"en-US,en;q=0.9\"\n          ],\n          \"trailers\": {},\n          \"rawTrailers\": [],\n          \"aborted\": false,\n          \"upgrade\": false,\n          \"url\": \"/\",\n          \"method\": \"GET\",\n          \"statusCode\": null,\n          \"statusMessage\": null,\n          \"client\": \"[Circular ~.res.socket]\",\n          \"_consuming\": false,\n          \"_dumped\": false,\n          \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n          \"baseUrl\": \"\",\n          \"originalUrl\": \"/\",\n          \"_parsedUrl\": {\n            \"protocol\": null,\n            \"slashes\": null,\n            \"auth\": null,\n            \"host\": null,\n            \"port\": null,\n            \"hostname\": null,\n            \"hash\": null,\n            \"search\": null,\n            \"query\": null,\n            \"pathname\": \"/\",\n            \"path\": \"/\",\n            \"href\": \"/\",\n            \"_raw\": \"/\"\n          },\n          \"params\": {},\n          \"query\": {},\n          \"res\": \"[Circular ~.res]\",\n          \"body\": {},\n          \"_startAt\": [\n            118370,\n            472086741\n          ],\n          \"_startTime\": \"2020-11-30T04:16:43.273Z\",\n          \"_remoteAddress\": \"::1\"\n        },\n        \"outgoing\": null,\n        \"maxHeaderPairs\": 2000,\n        \"_consumed\": true,\n        \"onIncoming\": function () { [native code] }\n      },\n      \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"_paused\": false,\n      \"_httpMessage\": \"[Circular ~.res]\",\n      \"_peername\": {\n        \"address\": \"::1\",\n        \"family\": \"IPv6\",\n        \"port\": 33946\n      }\n    },\n    \"_header\": null,\n    \"_keepAliveTimeout\": 5000,\n    \"_onPendingData\": function () { [native code] },\n    \"_sent100\": false,\n    \"_expect_continue\": false,\n    \"req\": {\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": null,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": false,\n        \"sync\": true,\n        \"needReadable\": false,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": true,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": true,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n      },\n      \"_eventsCount\": 1,\n      \"socket\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": true,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.socket]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 33946\n        }\n      },\n      \"httpVersionMajor\": 1,\n      \"httpVersionMinor\": 1,\n      \"httpVersion\": \"1.1\",\n      \"complete\": false,\n      \"headers\": {\n        \"host\": \"localhost:3000\",\n        \"connection\": \"keep-alive\",\n        \"upgrade-insecure-requests\": \"1\",\n        \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n        \"sec-fetch-site\": \"none\",\n        \"sec-fetch-mode\": \"navigate\",\n        \"sec-fetch-user\": \"?1\",\n        \"sec-fetch-dest\": \"document\",\n        \"accept-encoding\": \"gzip, deflate, br\",\n        \"accept-language\": \"en-US,en;q=0.9\"\n      },\n      \"rawHeaders\": [\n        \"Host\",\n        \"localhost:3000\",\n        \"Connection\",\n        \"keep-alive\",\n        \"Upgrade-Insecure-Requests\",\n        \"1\",\n        \"User-Agent\",\n        \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"Accept\",\n        \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n        \"Sec-Fetch-Site\",\n        \"none\",\n        \"Sec-Fetch-Mode\",\n        \"navigate\",\n        \"Sec-Fetch-User\",\n        \"?1\",\n        \"Sec-Fetch-Dest\",\n        \"document\",\n        \"Accept-Encoding\",\n        \"gzip, deflate, br\",\n        \"Accept-Language\",\n        \"en-US,en;q=0.9\"\n      ],\n      \"trailers\": {},\n      \"rawTrailers\": [],\n      \"aborted\": false,\n      \"upgrade\": false,\n      \"url\": \"/\",\n      \"method\": \"GET\",\n      \"statusCode\": null,\n      \"statusMessage\": null,\n      \"client\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": true,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.client]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 33946\n        }\n      },\n      \"_consuming\": false,\n      \"_dumped\": false,\n      \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n      \"baseUrl\": \"\",\n      \"originalUrl\": \"/\",\n      \"_parsedUrl\": {\n        \"protocol\": null,\n        \"slashes\": null,\n        \"auth\": null,\n        \"host\": null,\n        \"port\": null,\n        \"hostname\": null,\n        \"hash\": null,\n        \"search\": null,\n        \"query\": null,\n        \"pathname\": \"/\",\n        \"path\": \"/\",\n        \"href\": \"/\",\n        \"_raw\": \"/\"\n      },\n      \"params\": {},\n      \"query\": {},\n      \"res\": \"[Circular ~.res]\",\n      \"body\": {},\n      \"_startAt\": [\n        118370,\n        472086741\n      ],\n      \"_startTime\": \"2020-11-30T04:16:43.273Z\",\n      \"_remoteAddress\": \"::1\"\n    },\n    \"locals\": {},\n    \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n    \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n    \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n    \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n    \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n    \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n  },\n  \"body\": {},\n  \"_startAt\": [\n    118370,\n    472086741\n  ],\n  \"_startTime\": \"2020-11-30T04:16:43.273Z\",\n  \"_remoteAddress\": \"::1\",\n  \"statusCode\" \u001b[31m[1]\u001b[0m: null\n}\n\u001b[31m\n[1] \"statusCode\" must be one of [400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511]\u001b[0m","level":"error","service":"monkey"}
{"message":"{\n  \"_readableState\": {\n    \"objectMode\": false,\n    \"highWaterMark\": 16384,\n    \"buffer\": {\n      \"head\": null,\n      \"tail\": null,\n      \"length\": 0\n    },\n    \"length\": 0,\n    \"pipes\": [],\n    \"flowing\": null,\n    \"ended\": false,\n    \"endEmitted\": false,\n    \"reading\": false,\n    \"sync\": true,\n    \"needReadable\": false,\n    \"emittedReadable\": false,\n    \"readableListening\": false,\n    \"resumeScheduled\": false,\n    \"errorEmitted\": false,\n    \"emitClose\": true,\n    \"autoDestroy\": false,\n    \"destroyed\": false,\n    \"errored\": null,\n    \"closed\": false,\n    \"closeEmitted\": false,\n    \"defaultEncoding\": \"utf8\",\n    \"awaitDrainWriters\": null,\n    \"multiAwaitDrain\": false,\n    \"readingMore\": true,\n    \"decoder\": null,\n    \"encoding\": null\n  },\n  \"_events\": {\n    \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n  },\n  \"_eventsCount\": 1,\n  \"socket\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": false,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.socket]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.socket]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.socket.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118370,\n          654000178\n        ],\n        \"_startTime\": \"2020-11-30T04:16:43.455Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.socket]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.socket._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118370,\n          654000178\n        ],\n        \"_startTime\": \"2020-11-30T04:16:43.455Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 33946\n    },\n    \"timeout\": 0\n  },\n  \"httpVersionMajor\": 1,\n  \"httpVersionMinor\": 1,\n  \"httpVersion\": \"1.1\",\n  \"complete\": false,\n  \"headers\": {\n    \"host\": \"localhost:3000\",\n    \"connection\": \"keep-alive\",\n    \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n    \"sec-fetch-site\": \"same-origin\",\n    \"sec-fetch-mode\": \"no-cors\",\n    \"sec-fetch-dest\": \"image\",\n    \"accept-encoding\": \"gzip, deflate, br\",\n    \"accept-language\": \"en-US,en;q=0.9\"\n  },\n  \"rawHeaders\": [\n    \"Host\",\n    \"localhost:3000\",\n    \"Connection\",\n    \"keep-alive\",\n    \"User-Agent\",\n    \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"Accept\",\n    \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n    \"Sec-Fetch-Site\",\n    \"same-origin\",\n    \"Sec-Fetch-Mode\",\n    \"no-cors\",\n    \"Sec-Fetch-Dest\",\n    \"image\",\n    \"Accept-Encoding\",\n    \"gzip, deflate, br\",\n    \"Accept-Language\",\n    \"en-US,en;q=0.9\"\n  ],\n  \"trailers\": {},\n  \"rawTrailers\": [],\n  \"aborted\": false,\n  \"upgrade\": false,\n  \"url\": \"/favicon.ico\",\n  \"method\": \"GET\",\n  \"statusMessage\": null,\n  \"client\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": false,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.client]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.client]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.client.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118370,\n          654000178\n        ],\n        \"_startTime\": \"2020-11-30T04:16:43.455Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.client]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.client._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118370,\n          654000178\n        ],\n        \"_startTime\": \"2020-11-30T04:16:43.455Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 33946\n    },\n    \"timeout\": 0\n  },\n  \"_consuming\": false,\n  \"_dumped\": false,\n  \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n  \"baseUrl\": \"\",\n  \"originalUrl\": \"/favicon.ico\",\n  \"_parsedUrl\": {\n    \"protocol\": null,\n    \"slashes\": null,\n    \"auth\": null,\n    \"host\": null,\n    \"port\": null,\n    \"hostname\": null,\n    \"hash\": null,\n    \"search\": null,\n    \"query\": null,\n    \"pathname\": \"/favicon.ico\",\n    \"path\": \"/favicon.ico\",\n    \"href\": \"/favicon.ico\",\n    \"_raw\": \"/favicon.ico\"\n  },\n  \"params\": {},\n  \"query\": {},\n  \"res\": {\n    \"_events\": {\n      \"finish\": [\n        function () { [native code] },\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n    },\n    \"_eventsCount\": 2,\n    \"outputData\": [],\n    \"outputSize\": 0,\n    \"writable\": true,\n    \"destroyed\": false,\n    \"_last\": false,\n    \"chunkedEncoding\": false,\n    \"shouldKeepAlive\": true,\n    \"_defaultKeepAlive\": true,\n    \"useChunkedEncodingByDefault\": true,\n    \"sendDate\": true,\n    \"_removedConnection\": false,\n    \"_removedContLen\": false,\n    \"_removedTE\": false,\n    \"_contentLength\": null,\n    \"_hasBody\": true,\n    \"_trailer\": \"\",\n    \"finished\": false,\n    \"_headerSent\": false,\n    \"socket\": {\n      \"connecting\": false,\n      \"_hadError\": false,\n      \"_parent\": null,\n      \"_host\": null,\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": true,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": true,\n        \"sync\": false,\n        \"needReadable\": true,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": false,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": [\n          function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n          function () { [native code] }\n        ],\n        \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n        \"data\": function () { [native code] },\n        \"error\": [\n          function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"close\": [\n          function () { [native code] },\n          function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"drain\": function () { [native code] },\n        \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n        \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n      },\n      \"_eventsCount\": 8,\n      \"_writableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"finalCalled\": false,\n        \"needDrain\": false,\n        \"ending\": false,\n        \"ended\": false,\n        \"finished\": false,\n        \"destroyed\": false,\n        \"decodeStrings\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"length\": 0,\n        \"writing\": false,\n        \"corked\": 0,\n        \"sync\": false,\n        \"bufferProcessing\": false,\n        \"onwrite\": function () { [native code] },\n        \"writecb\": null,\n        \"writelen\": 0,\n        \"afterWriteTickInfo\": null,\n        \"buffered\": [],\n        \"bufferedIndex\": 0,\n        \"allBuffers\": true,\n        \"allNoop\": true,\n        \"pendingcb\": 0,\n        \"prefinished\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false\n      },\n      \"allowHalfOpen\": true,\n      \"_sockname\": null,\n      \"_pendingData\": null,\n      \"_pendingEncoding\": \"\",\n      \"server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"_server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"parser\": {\n        \"0\": function () { [native code] },\n        \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n        \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n        \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n        \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n        \"5\": function () { [native code] },\n        \"6\": function () { [native code] },\n        \"_headers\": [],\n        \"_url\": \"\",\n        \"socket\": \"[Circular ~.res.socket]\",\n        \"incoming\": {\n          \"_readableState\": {\n            \"objectMode\": false,\n            \"highWaterMark\": 16384,\n            \"buffer\": {\n              \"head\": null,\n              \"tail\": null,\n              \"length\": 0\n            },\n            \"length\": 0,\n            \"pipes\": [],\n            \"flowing\": null,\n            \"ended\": false,\n            \"endEmitted\": false,\n            \"reading\": false,\n            \"sync\": true,\n            \"needReadable\": false,\n            \"emittedReadable\": false,\n            \"readableListening\": false,\n            \"resumeScheduled\": false,\n            \"errorEmitted\": false,\n            \"emitClose\": true,\n            \"autoDestroy\": false,\n            \"destroyed\": false,\n            \"errored\": null,\n            \"closed\": false,\n            \"closeEmitted\": false,\n            \"defaultEncoding\": \"utf8\",\n            \"awaitDrainWriters\": null,\n            \"multiAwaitDrain\": false,\n            \"readingMore\": true,\n            \"decoder\": null,\n            \"encoding\": null\n          },\n          \"_events\": {\n            \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n          },\n          \"_eventsCount\": 1,\n          \"socket\": \"[Circular ~.res.socket]\",\n          \"httpVersionMajor\": 1,\n          \"httpVersionMinor\": 1,\n          \"httpVersion\": \"1.1\",\n          \"complete\": false,\n          \"headers\": {\n            \"host\": \"localhost:3000\",\n            \"connection\": \"keep-alive\",\n            \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n            \"sec-fetch-site\": \"same-origin\",\n            \"sec-fetch-mode\": \"no-cors\",\n            \"sec-fetch-dest\": \"image\",\n            \"accept-encoding\": \"gzip, deflate, br\",\n            \"accept-language\": \"en-US,en;q=0.9\"\n          },\n          \"rawHeaders\": [\n            \"Host\",\n            \"localhost:3000\",\n            \"Connection\",\n            \"keep-alive\",\n            \"User-Agent\",\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"Accept\",\n            \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n            \"Sec-Fetch-Site\",\n            \"same-origin\",\n            \"Sec-Fetch-Mode\",\n            \"no-cors\",\n            \"Sec-Fetch-Dest\",\n            \"image\",\n            \"Accept-Encoding\",\n            \"gzip, deflate, br\",\n            \"Accept-Language\",\n            \"en-US,en;q=0.9\"\n          ],\n          \"trailers\": {},\n          \"rawTrailers\": [],\n          \"aborted\": false,\n          \"upgrade\": false,\n          \"url\": \"/favicon.ico\",\n          \"method\": \"GET\",\n          \"statusCode\": null,\n          \"statusMessage\": null,\n          \"client\": \"[Circular ~.res.socket]\",\n          \"_consuming\": false,\n          \"_dumped\": false,\n          \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n          \"baseUrl\": \"\",\n          \"originalUrl\": \"/favicon.ico\",\n          \"_parsedUrl\": {\n            \"protocol\": null,\n            \"slashes\": null,\n            \"auth\": null,\n            \"host\": null,\n            \"port\": null,\n            \"hostname\": null,\n            \"hash\": null,\n            \"search\": null,\n            \"query\": null,\n            \"pathname\": \"/favicon.ico\",\n            \"path\": \"/favicon.ico\",\n            \"href\": \"/favicon.ico\",\n            \"_raw\": \"/favicon.ico\"\n          },\n          \"params\": {},\n          \"query\": {},\n          \"res\": \"[Circular ~.res]\",\n          \"body\": {},\n          \"_startAt\": [\n            118370,\n            654000178\n          ],\n          \"_startTime\": \"2020-11-30T04:16:43.455Z\",\n          \"_remoteAddress\": \"::1\"\n        },\n        \"outgoing\": null,\n        \"maxHeaderPairs\": 2000,\n        \"_consumed\": true,\n        \"onIncoming\": function () { [native code] }\n      },\n      \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"_paused\": false,\n      \"_httpMessage\": \"[Circular ~.res]\",\n      \"_peername\": {\n        \"address\": \"::1\",\n        \"family\": \"IPv6\",\n        \"port\": 33946\n      },\n      \"timeout\": 0\n    },\n    \"_header\": null,\n    \"_keepAliveTimeout\": 5000,\n    \"_onPendingData\": function () { [native code] },\n    \"_sent100\": false,\n    \"_expect_continue\": false,\n    \"req\": {\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": null,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": false,\n        \"sync\": true,\n        \"needReadable\": false,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": true,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": true,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n      },\n      \"_eventsCount\": 1,\n      \"socket\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": false,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.socket]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 33946\n        },\n        \"timeout\": 0\n      },\n      \"httpVersionMajor\": 1,\n      \"httpVersionMinor\": 1,\n      \"httpVersion\": \"1.1\",\n      \"complete\": false,\n      \"headers\": {\n        \"host\": \"localhost:3000\",\n        \"connection\": \"keep-alive\",\n        \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n        \"sec-fetch-site\": \"same-origin\",\n        \"sec-fetch-mode\": \"no-cors\",\n        \"sec-fetch-dest\": \"image\",\n        \"accept-encoding\": \"gzip, deflate, br\",\n        \"accept-language\": \"en-US,en;q=0.9\"\n      },\n      \"rawHeaders\": [\n        \"Host\",\n        \"localhost:3000\",\n        \"Connection\",\n        \"keep-alive\",\n        \"User-Agent\",\n        \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"Accept\",\n        \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n        \"Sec-Fetch-Site\",\n        \"same-origin\",\n        \"Sec-Fetch-Mode\",\n        \"no-cors\",\n        \"Sec-Fetch-Dest\",\n        \"image\",\n        \"Accept-Encoding\",\n        \"gzip, deflate, br\",\n        \"Accept-Language\",\n        \"en-US,en;q=0.9\"\n      ],\n      \"trailers\": {},\n      \"rawTrailers\": [],\n      \"aborted\": false,\n      \"upgrade\": false,\n      \"url\": \"/favicon.ico\",\n      \"method\": \"GET\",\n      \"statusCode\": null,\n      \"statusMessage\": null,\n      \"client\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": false,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.client]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 33946\n        },\n        \"timeout\": 0\n      },\n      \"_consuming\": false,\n      \"_dumped\": false,\n      \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n      \"baseUrl\": \"\",\n      \"originalUrl\": \"/favicon.ico\",\n      \"_parsedUrl\": {\n        \"protocol\": null,\n        \"slashes\": null,\n        \"auth\": null,\n        \"host\": null,\n        \"port\": null,\n        \"hostname\": null,\n        \"hash\": null,\n        \"search\": null,\n        \"query\": null,\n        \"pathname\": \"/favicon.ico\",\n        \"path\": \"/favicon.ico\",\n        \"href\": \"/favicon.ico\",\n        \"_raw\": \"/favicon.ico\"\n      },\n      \"params\": {},\n      \"query\": {},\n      \"res\": \"[Circular ~.res]\",\n      \"body\": {},\n      \"_startAt\": [\n        118370,\n        654000178\n      ],\n      \"_startTime\": \"2020-11-30T04:16:43.455Z\",\n      \"_remoteAddress\": \"::1\"\n    },\n    \"locals\": {},\n    \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n    \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n    \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n    \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n    \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n    \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n  },\n  \"body\": {},\n  \"_startAt\": [\n    118370,\n    654000178\n  ],\n  \"_startTime\": \"2020-11-30T04:16:43.455Z\",\n  \"_remoteAddress\": \"::1\",\n  \"statusCode\" \u001b[31m[1]\u001b[0m: null\n}\n\u001b[31m\n[1] \"statusCode\" must be one of [400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511]\u001b[0m","level":"error","service":"monkey"}
{"message":"{\n  \"_readableState\": {\n    \"objectMode\": false,\n    \"highWaterMark\": 16384,\n    \"buffer\": {\n      \"head\": null,\n      \"tail\": null,\n      \"length\": 0\n    },\n    \"length\": 0,\n    \"pipes\": [],\n    \"flowing\": null,\n    \"ended\": false,\n    \"endEmitted\": false,\n    \"reading\": false,\n    \"sync\": true,\n    \"needReadable\": false,\n    \"emittedReadable\": false,\n    \"readableListening\": false,\n    \"resumeScheduled\": false,\n    \"errorEmitted\": false,\n    \"emitClose\": true,\n    \"autoDestroy\": false,\n    \"destroyed\": false,\n    \"errored\": null,\n    \"closed\": false,\n    \"closeEmitted\": false,\n    \"defaultEncoding\": \"utf8\",\n    \"awaitDrainWriters\": null,\n    \"multiAwaitDrain\": false,\n    \"readingMore\": true,\n    \"decoder\": null,\n    \"encoding\": null\n  },\n  \"_events\": {\n    \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n  },\n  \"_eventsCount\": 1,\n  \"socket\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": true,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.socket]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"cache-control\": \"max-age=0\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Cache-Control\",\n          \"max-age=0\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.socket]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.socket.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118516,\n          354803171\n        ],\n        \"_startTime\": \"2020-11-30T04:19:09.156Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.socket]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"cache-control\": \"max-age=0\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Cache-Control\",\n          \"max-age=0\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.socket._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118516,\n          354803171\n        ],\n        \"_startTime\": \"2020-11-30T04:19:09.156Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 34018\n    }\n  },\n  \"httpVersionMajor\": 1,\n  \"httpVersionMinor\": 1,\n  \"httpVersion\": \"1.1\",\n  \"complete\": false,\n  \"headers\": {\n    \"host\": \"localhost:3000\",\n    \"connection\": \"keep-alive\",\n    \"cache-control\": \"max-age=0\",\n    \"upgrade-insecure-requests\": \"1\",\n    \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n    \"sec-fetch-site\": \"none\",\n    \"sec-fetch-mode\": \"navigate\",\n    \"sec-fetch-user\": \"?1\",\n    \"sec-fetch-dest\": \"document\",\n    \"accept-encoding\": \"gzip, deflate, br\",\n    \"accept-language\": \"en-US,en;q=0.9\"\n  },\n  \"rawHeaders\": [\n    \"Host\",\n    \"localhost:3000\",\n    \"Connection\",\n    \"keep-alive\",\n    \"Cache-Control\",\n    \"max-age=0\",\n    \"Upgrade-Insecure-Requests\",\n    \"1\",\n    \"User-Agent\",\n    \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"Accept\",\n    \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n    \"Sec-Fetch-Site\",\n    \"none\",\n    \"Sec-Fetch-Mode\",\n    \"navigate\",\n    \"Sec-Fetch-User\",\n    \"?1\",\n    \"Sec-Fetch-Dest\",\n    \"document\",\n    \"Accept-Encoding\",\n    \"gzip, deflate, br\",\n    \"Accept-Language\",\n    \"en-US,en;q=0.9\"\n  ],\n  \"trailers\": {},\n  \"rawTrailers\": [],\n  \"aborted\": false,\n  \"upgrade\": false,\n  \"url\": \"/\",\n  \"method\": \"GET\",\n  \"statusMessage\": null,\n  \"client\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": true,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.client]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"cache-control\": \"max-age=0\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Cache-Control\",\n          \"max-age=0\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.client]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.client.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118516,\n          354803171\n        ],\n        \"_startTime\": \"2020-11-30T04:19:09.156Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.client]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"cache-control\": \"max-age=0\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Cache-Control\",\n          \"max-age=0\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.client._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118516,\n          354803171\n        ],\n        \"_startTime\": \"2020-11-30T04:19:09.156Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 34018\n    }\n  },\n  \"_consuming\": false,\n  \"_dumped\": false,\n  \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n  \"baseUrl\": \"\",\n  \"originalUrl\": \"/\",\n  \"_parsedUrl\": {\n    \"protocol\": null,\n    \"slashes\": null,\n    \"auth\": null,\n    \"host\": null,\n    \"port\": null,\n    \"hostname\": null,\n    \"hash\": null,\n    \"search\": null,\n    \"query\": null,\n    \"pathname\": \"/\",\n    \"path\": \"/\",\n    \"href\": \"/\",\n    \"_raw\": \"/\"\n  },\n  \"params\": {},\n  \"query\": {},\n  \"res\": {\n    \"_events\": {\n      \"finish\": [\n        function () { [native code] },\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n    },\n    \"_eventsCount\": 2,\n    \"outputData\": [],\n    \"outputSize\": 0,\n    \"writable\": true,\n    \"destroyed\": false,\n    \"_last\": false,\n    \"chunkedEncoding\": false,\n    \"shouldKeepAlive\": true,\n    \"_defaultKeepAlive\": true,\n    \"useChunkedEncodingByDefault\": true,\n    \"sendDate\": true,\n    \"_removedConnection\": false,\n    \"_removedContLen\": false,\n    \"_removedTE\": false,\n    \"_contentLength\": null,\n    \"_hasBody\": true,\n    \"_trailer\": \"\",\n    \"finished\": false,\n    \"_headerSent\": false,\n    \"socket\": {\n      \"connecting\": false,\n      \"_hadError\": false,\n      \"_parent\": null,\n      \"_host\": null,\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": true,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": true,\n        \"sync\": false,\n        \"needReadable\": true,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": false,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": [\n          function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n          function () { [native code] }\n        ],\n        \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n        \"data\": function () { [native code] },\n        \"error\": [\n          function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"close\": [\n          function () { [native code] },\n          function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"drain\": function () { [native code] },\n        \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n        \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n      },\n      \"_eventsCount\": 8,\n      \"_writableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"finalCalled\": false,\n        \"needDrain\": false,\n        \"ending\": false,\n        \"ended\": false,\n        \"finished\": false,\n        \"destroyed\": false,\n        \"decodeStrings\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"length\": 0,\n        \"writing\": false,\n        \"corked\": 0,\n        \"sync\": true,\n        \"bufferProcessing\": false,\n        \"onwrite\": function () { [native code] },\n        \"writecb\": null,\n        \"writelen\": 0,\n        \"afterWriteTickInfo\": null,\n        \"buffered\": [],\n        \"bufferedIndex\": 0,\n        \"allBuffers\": true,\n        \"allNoop\": true,\n        \"pendingcb\": 0,\n        \"prefinished\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false\n      },\n      \"allowHalfOpen\": true,\n      \"_sockname\": null,\n      \"_pendingData\": null,\n      \"_pendingEncoding\": \"\",\n      \"server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"_server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"parser\": {\n        \"0\": function () { [native code] },\n        \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n        \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n        \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n        \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n        \"5\": function () { [native code] },\n        \"6\": function () { [native code] },\n        \"_headers\": [],\n        \"_url\": \"\",\n        \"socket\": \"[Circular ~.res.socket]\",\n        \"incoming\": {\n          \"_readableState\": {\n            \"objectMode\": false,\n            \"highWaterMark\": 16384,\n            \"buffer\": {\n              \"head\": null,\n              \"tail\": null,\n              \"length\": 0\n            },\n            \"length\": 0,\n            \"pipes\": [],\n            \"flowing\": null,\n            \"ended\": false,\n            \"endEmitted\": false,\n            \"reading\": false,\n            \"sync\": true,\n            \"needReadable\": false,\n            \"emittedReadable\": false,\n            \"readableListening\": false,\n            \"resumeScheduled\": false,\n            \"errorEmitted\": false,\n            \"emitClose\": true,\n            \"autoDestroy\": false,\n            \"destroyed\": false,\n            \"errored\": null,\n            \"closed\": false,\n            \"closeEmitted\": false,\n            \"defaultEncoding\": \"utf8\",\n            \"awaitDrainWriters\": null,\n            \"multiAwaitDrain\": false,\n            \"readingMore\": true,\n            \"decoder\": null,\n            \"encoding\": null\n          },\n          \"_events\": {\n            \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n          },\n          \"_eventsCount\": 1,\n          \"socket\": \"[Circular ~.res.socket]\",\n          \"httpVersionMajor\": 1,\n          \"httpVersionMinor\": 1,\n          \"httpVersion\": \"1.1\",\n          \"complete\": false,\n          \"headers\": {\n            \"host\": \"localhost:3000\",\n            \"connection\": \"keep-alive\",\n            \"cache-control\": \"max-age=0\",\n            \"upgrade-insecure-requests\": \"1\",\n            \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n            \"sec-fetch-site\": \"none\",\n            \"sec-fetch-mode\": \"navigate\",\n            \"sec-fetch-user\": \"?1\",\n            \"sec-fetch-dest\": \"document\",\n            \"accept-encoding\": \"gzip, deflate, br\",\n            \"accept-language\": \"en-US,en;q=0.9\"\n          },\n          \"rawHeaders\": [\n            \"Host\",\n            \"localhost:3000\",\n            \"Connection\",\n            \"keep-alive\",\n            \"Cache-Control\",\n            \"max-age=0\",\n            \"Upgrade-Insecure-Requests\",\n            \"1\",\n            \"User-Agent\",\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"Accept\",\n            \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n            \"Sec-Fetch-Site\",\n            \"none\",\n            \"Sec-Fetch-Mode\",\n            \"navigate\",\n            \"Sec-Fetch-User\",\n            \"?1\",\n            \"Sec-Fetch-Dest\",\n            \"document\",\n            \"Accept-Encoding\",\n            \"gzip, deflate, br\",\n            \"Accept-Language\",\n            \"en-US,en;q=0.9\"\n          ],\n          \"trailers\": {},\n          \"rawTrailers\": [],\n          \"aborted\": false,\n          \"upgrade\": false,\n          \"url\": \"/\",\n          \"method\": \"GET\",\n          \"statusCode\": null,\n          \"statusMessage\": null,\n          \"client\": \"[Circular ~.res.socket]\",\n          \"_consuming\": false,\n          \"_dumped\": false,\n          \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n          \"baseUrl\": \"\",\n          \"originalUrl\": \"/\",\n          \"_parsedUrl\": {\n            \"protocol\": null,\n            \"slashes\": null,\n            \"auth\": null,\n            \"host\": null,\n            \"port\": null,\n            \"hostname\": null,\n            \"hash\": null,\n            \"search\": null,\n            \"query\": null,\n            \"pathname\": \"/\",\n            \"path\": \"/\",\n            \"href\": \"/\",\n            \"_raw\": \"/\"\n          },\n          \"params\": {},\n          \"query\": {},\n          \"res\": \"[Circular ~.res]\",\n          \"body\": {},\n          \"_startAt\": [\n            118516,\n            354803171\n          ],\n          \"_startTime\": \"2020-11-30T04:19:09.156Z\",\n          \"_remoteAddress\": \"::1\"\n        },\n        \"outgoing\": null,\n        \"maxHeaderPairs\": 2000,\n        \"_consumed\": true,\n        \"onIncoming\": function () { [native code] }\n      },\n      \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"_paused\": false,\n      \"_httpMessage\": \"[Circular ~.res]\",\n      \"_peername\": {\n        \"address\": \"::1\",\n        \"family\": \"IPv6\",\n        \"port\": 34018\n      }\n    },\n    \"_header\": null,\n    \"_keepAliveTimeout\": 5000,\n    \"_onPendingData\": function () { [native code] },\n    \"_sent100\": false,\n    \"_expect_continue\": false,\n    \"req\": {\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": null,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": false,\n        \"sync\": true,\n        \"needReadable\": false,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": true,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": true,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n      },\n      \"_eventsCount\": 1,\n      \"socket\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": true,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.socket]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 34018\n        }\n      },\n      \"httpVersionMajor\": 1,\n      \"httpVersionMinor\": 1,\n      \"httpVersion\": \"1.1\",\n      \"complete\": false,\n      \"headers\": {\n        \"host\": \"localhost:3000\",\n        \"connection\": \"keep-alive\",\n        \"cache-control\": \"max-age=0\",\n        \"upgrade-insecure-requests\": \"1\",\n        \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n        \"sec-fetch-site\": \"none\",\n        \"sec-fetch-mode\": \"navigate\",\n        \"sec-fetch-user\": \"?1\",\n        \"sec-fetch-dest\": \"document\",\n        \"accept-encoding\": \"gzip, deflate, br\",\n        \"accept-language\": \"en-US,en;q=0.9\"\n      },\n      \"rawHeaders\": [\n        \"Host\",\n        \"localhost:3000\",\n        \"Connection\",\n        \"keep-alive\",\n        \"Cache-Control\",\n        \"max-age=0\",\n        \"Upgrade-Insecure-Requests\",\n        \"1\",\n        \"User-Agent\",\n        \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"Accept\",\n        \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n        \"Sec-Fetch-Site\",\n        \"none\",\n        \"Sec-Fetch-Mode\",\n        \"navigate\",\n        \"Sec-Fetch-User\",\n        \"?1\",\n        \"Sec-Fetch-Dest\",\n        \"document\",\n        \"Accept-Encoding\",\n        \"gzip, deflate, br\",\n        \"Accept-Language\",\n        \"en-US,en;q=0.9\"\n      ],\n      \"trailers\": {},\n      \"rawTrailers\": [],\n      \"aborted\": false,\n      \"upgrade\": false,\n      \"url\": \"/\",\n      \"method\": \"GET\",\n      \"statusCode\": null,\n      \"statusMessage\": null,\n      \"client\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": true,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.client]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 34018\n        }\n      },\n      \"_consuming\": false,\n      \"_dumped\": false,\n      \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n      \"baseUrl\": \"\",\n      \"originalUrl\": \"/\",\n      \"_parsedUrl\": {\n        \"protocol\": null,\n        \"slashes\": null,\n        \"auth\": null,\n        \"host\": null,\n        \"port\": null,\n        \"hostname\": null,\n        \"hash\": null,\n        \"search\": null,\n        \"query\": null,\n        \"pathname\": \"/\",\n        \"path\": \"/\",\n        \"href\": \"/\",\n        \"_raw\": \"/\"\n      },\n      \"params\": {},\n      \"query\": {},\n      \"res\": \"[Circular ~.res]\",\n      \"body\": {},\n      \"_startAt\": [\n        118516,\n        354803171\n      ],\n      \"_startTime\": \"2020-11-30T04:19:09.156Z\",\n      \"_remoteAddress\": \"::1\"\n    },\n    \"locals\": {},\n    \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n    \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n    \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n    \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n    \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n    \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n  },\n  \"body\": {},\n  \"_startAt\": [\n    118516,\n    354803171\n  ],\n  \"_startTime\": \"2020-11-30T04:19:09.156Z\",\n  \"_remoteAddress\": \"::1\",\n  \"statusCode\" \u001b[31m[1]\u001b[0m: null\n}\n\u001b[31m\n[1] \"statusCode\" must be one of [400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511]\u001b[0m","level":"error","service":"monkey"}
{"message":"{\n  \"_readableState\": {\n    \"objectMode\": false,\n    \"highWaterMark\": 16384,\n    \"buffer\": {\n      \"head\": null,\n      \"tail\": null,\n      \"length\": 0\n    },\n    \"length\": 0,\n    \"pipes\": [],\n    \"flowing\": null,\n    \"ended\": false,\n    \"endEmitted\": false,\n    \"reading\": false,\n    \"sync\": true,\n    \"needReadable\": false,\n    \"emittedReadable\": false,\n    \"readableListening\": false,\n    \"resumeScheduled\": false,\n    \"errorEmitted\": false,\n    \"emitClose\": true,\n    \"autoDestroy\": false,\n    \"destroyed\": false,\n    \"errored\": null,\n    \"closed\": false,\n    \"closeEmitted\": false,\n    \"defaultEncoding\": \"utf8\",\n    \"awaitDrainWriters\": null,\n    \"multiAwaitDrain\": false,\n    \"readingMore\": true,\n    \"decoder\": null,\n    \"encoding\": null\n  },\n  \"_events\": {\n    \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n  },\n  \"_eventsCount\": 1,\n  \"socket\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": false,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.socket]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.socket]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.socket.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118516,\n          480589246\n        ],\n        \"_startTime\": \"2020-11-30T04:19:09.282Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.socket]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.socket._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118516,\n          480589246\n        ],\n        \"_startTime\": \"2020-11-30T04:19:09.282Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 34018\n    },\n    \"timeout\": 0\n  },\n  \"httpVersionMajor\": 1,\n  \"httpVersionMinor\": 1,\n  \"httpVersion\": \"1.1\",\n  \"complete\": false,\n  \"headers\": {\n    \"host\": \"localhost:3000\",\n    \"connection\": \"keep-alive\",\n    \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n    \"sec-fetch-site\": \"same-origin\",\n    \"sec-fetch-mode\": \"no-cors\",\n    \"sec-fetch-dest\": \"image\",\n    \"accept-encoding\": \"gzip, deflate, br\",\n    \"accept-language\": \"en-US,en;q=0.9\"\n  },\n  \"rawHeaders\": [\n    \"Host\",\n    \"localhost:3000\",\n    \"Connection\",\n    \"keep-alive\",\n    \"User-Agent\",\n    \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"Accept\",\n    \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n    \"Sec-Fetch-Site\",\n    \"same-origin\",\n    \"Sec-Fetch-Mode\",\n    \"no-cors\",\n    \"Sec-Fetch-Dest\",\n    \"image\",\n    \"Accept-Encoding\",\n    \"gzip, deflate, br\",\n    \"Accept-Language\",\n    \"en-US,en;q=0.9\"\n  ],\n  \"trailers\": {},\n  \"rawTrailers\": [],\n  \"aborted\": false,\n  \"upgrade\": false,\n  \"url\": \"/favicon.ico\",\n  \"method\": \"GET\",\n  \"statusMessage\": null,\n  \"client\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": false,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.client]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.client]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.client.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118516,\n          480589246\n        ],\n        \"_startTime\": \"2020-11-30T04:19:09.282Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.client]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.client._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118516,\n          480589246\n        ],\n        \"_startTime\": \"2020-11-30T04:19:09.282Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 34018\n    },\n    \"timeout\": 0\n  },\n  \"_consuming\": false,\n  \"_dumped\": false,\n  \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n  \"baseUrl\": \"\",\n  \"originalUrl\": \"/favicon.ico\",\n  \"_parsedUrl\": {\n    \"protocol\": null,\n    \"slashes\": null,\n    \"auth\": null,\n    \"host\": null,\n    \"port\": null,\n    \"hostname\": null,\n    \"hash\": null,\n    \"search\": null,\n    \"query\": null,\n    \"pathname\": \"/favicon.ico\",\n    \"path\": \"/favicon.ico\",\n    \"href\": \"/favicon.ico\",\n    \"_raw\": \"/favicon.ico\"\n  },\n  \"params\": {},\n  \"query\": {},\n  \"res\": {\n    \"_events\": {\n      \"finish\": [\n        function () { [native code] },\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n    },\n    \"_eventsCount\": 2,\n    \"outputData\": [],\n    \"outputSize\": 0,\n    \"writable\": true,\n    \"destroyed\": false,\n    \"_last\": false,\n    \"chunkedEncoding\": false,\n    \"shouldKeepAlive\": true,\n    \"_defaultKeepAlive\": true,\n    \"useChunkedEncodingByDefault\": true,\n    \"sendDate\": true,\n    \"_removedConnection\": false,\n    \"_removedContLen\": false,\n    \"_removedTE\": false,\n    \"_contentLength\": null,\n    \"_hasBody\": true,\n    \"_trailer\": \"\",\n    \"finished\": false,\n    \"_headerSent\": false,\n    \"socket\": {\n      \"connecting\": false,\n      \"_hadError\": false,\n      \"_parent\": null,\n      \"_host\": null,\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": true,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": true,\n        \"sync\": false,\n        \"needReadable\": true,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": false,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": [\n          function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n          function () { [native code] }\n        ],\n        \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n        \"data\": function () { [native code] },\n        \"error\": [\n          function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"close\": [\n          function () { [native code] },\n          function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"drain\": function () { [native code] },\n        \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n        \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n      },\n      \"_eventsCount\": 8,\n      \"_writableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"finalCalled\": false,\n        \"needDrain\": false,\n        \"ending\": false,\n        \"ended\": false,\n        \"finished\": false,\n        \"destroyed\": false,\n        \"decodeStrings\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"length\": 0,\n        \"writing\": false,\n        \"corked\": 0,\n        \"sync\": false,\n        \"bufferProcessing\": false,\n        \"onwrite\": function () { [native code] },\n        \"writecb\": null,\n        \"writelen\": 0,\n        \"afterWriteTickInfo\": null,\n        \"buffered\": [],\n        \"bufferedIndex\": 0,\n        \"allBuffers\": true,\n        \"allNoop\": true,\n        \"pendingcb\": 0,\n        \"prefinished\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false\n      },\n      \"allowHalfOpen\": true,\n      \"_sockname\": null,\n      \"_pendingData\": null,\n      \"_pendingEncoding\": \"\",\n      \"server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"_server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"parser\": {\n        \"0\": function () { [native code] },\n        \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n        \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n        \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n        \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n        \"5\": function () { [native code] },\n        \"6\": function () { [native code] },\n        \"_headers\": [],\n        \"_url\": \"\",\n        \"socket\": \"[Circular ~.res.socket]\",\n        \"incoming\": {\n          \"_readableState\": {\n            \"objectMode\": false,\n            \"highWaterMark\": 16384,\n            \"buffer\": {\n              \"head\": null,\n              \"tail\": null,\n              \"length\": 0\n            },\n            \"length\": 0,\n            \"pipes\": [],\n            \"flowing\": null,\n            \"ended\": false,\n            \"endEmitted\": false,\n            \"reading\": false,\n            \"sync\": true,\n            \"needReadable\": false,\n            \"emittedReadable\": false,\n            \"readableListening\": false,\n            \"resumeScheduled\": false,\n            \"errorEmitted\": false,\n            \"emitClose\": true,\n            \"autoDestroy\": false,\n            \"destroyed\": false,\n            \"errored\": null,\n            \"closed\": false,\n            \"closeEmitted\": false,\n            \"defaultEncoding\": \"utf8\",\n            \"awaitDrainWriters\": null,\n            \"multiAwaitDrain\": false,\n            \"readingMore\": true,\n            \"decoder\": null,\n            \"encoding\": null\n          },\n          \"_events\": {\n            \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n          },\n          \"_eventsCount\": 1,\n          \"socket\": \"[Circular ~.res.socket]\",\n          \"httpVersionMajor\": 1,\n          \"httpVersionMinor\": 1,\n          \"httpVersion\": \"1.1\",\n          \"complete\": false,\n          \"headers\": {\n            \"host\": \"localhost:3000\",\n            \"connection\": \"keep-alive\",\n            \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n            \"sec-fetch-site\": \"same-origin\",\n            \"sec-fetch-mode\": \"no-cors\",\n            \"sec-fetch-dest\": \"image\",\n            \"accept-encoding\": \"gzip, deflate, br\",\n            \"accept-language\": \"en-US,en;q=0.9\"\n          },\n          \"rawHeaders\": [\n            \"Host\",\n            \"localhost:3000\",\n            \"Connection\",\n            \"keep-alive\",\n            \"User-Agent\",\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"Accept\",\n            \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n            \"Sec-Fetch-Site\",\n            \"same-origin\",\n            \"Sec-Fetch-Mode\",\n            \"no-cors\",\n            \"Sec-Fetch-Dest\",\n            \"image\",\n            \"Accept-Encoding\",\n            \"gzip, deflate, br\",\n            \"Accept-Language\",\n            \"en-US,en;q=0.9\"\n          ],\n          \"trailers\": {},\n          \"rawTrailers\": [],\n          \"aborted\": false,\n          \"upgrade\": false,\n          \"url\": \"/favicon.ico\",\n          \"method\": \"GET\",\n          \"statusCode\": null,\n          \"statusMessage\": null,\n          \"client\": \"[Circular ~.res.socket]\",\n          \"_consuming\": false,\n          \"_dumped\": false,\n          \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n          \"baseUrl\": \"\",\n          \"originalUrl\": \"/favicon.ico\",\n          \"_parsedUrl\": {\n            \"protocol\": null,\n            \"slashes\": null,\n            \"auth\": null,\n            \"host\": null,\n            \"port\": null,\n            \"hostname\": null,\n            \"hash\": null,\n            \"search\": null,\n            \"query\": null,\n            \"pathname\": \"/favicon.ico\",\n            \"path\": \"/favicon.ico\",\n            \"href\": \"/favicon.ico\",\n            \"_raw\": \"/favicon.ico\"\n          },\n          \"params\": {},\n          \"query\": {},\n          \"res\": \"[Circular ~.res]\",\n          \"body\": {},\n          \"_startAt\": [\n            118516,\n            480589246\n          ],\n          \"_startTime\": \"2020-11-30T04:19:09.282Z\",\n          \"_remoteAddress\": \"::1\"\n        },\n        \"outgoing\": null,\n        \"maxHeaderPairs\": 2000,\n        \"_consumed\": true,\n        \"onIncoming\": function () { [native code] }\n      },\n      \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"_paused\": false,\n      \"_httpMessage\": \"[Circular ~.res]\",\n      \"_peername\": {\n        \"address\": \"::1\",\n        \"family\": \"IPv6\",\n        \"port\": 34018\n      },\n      \"timeout\": 0\n    },\n    \"_header\": null,\n    \"_keepAliveTimeout\": 5000,\n    \"_onPendingData\": function () { [native code] },\n    \"_sent100\": false,\n    \"_expect_continue\": false,\n    \"req\": {\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": null,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": false,\n        \"sync\": true,\n        \"needReadable\": false,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": true,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": true,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n      },\n      \"_eventsCount\": 1,\n      \"socket\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": false,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.socket]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 34018\n        },\n        \"timeout\": 0\n      },\n      \"httpVersionMajor\": 1,\n      \"httpVersionMinor\": 1,\n      \"httpVersion\": \"1.1\",\n      \"complete\": false,\n      \"headers\": {\n        \"host\": \"localhost:3000\",\n        \"connection\": \"keep-alive\",\n        \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n        \"sec-fetch-site\": \"same-origin\",\n        \"sec-fetch-mode\": \"no-cors\",\n        \"sec-fetch-dest\": \"image\",\n        \"accept-encoding\": \"gzip, deflate, br\",\n        \"accept-language\": \"en-US,en;q=0.9\"\n      },\n      \"rawHeaders\": [\n        \"Host\",\n        \"localhost:3000\",\n        \"Connection\",\n        \"keep-alive\",\n        \"User-Agent\",\n        \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"Accept\",\n        \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n        \"Sec-Fetch-Site\",\n        \"same-origin\",\n        \"Sec-Fetch-Mode\",\n        \"no-cors\",\n        \"Sec-Fetch-Dest\",\n        \"image\",\n        \"Accept-Encoding\",\n        \"gzip, deflate, br\",\n        \"Accept-Language\",\n        \"en-US,en;q=0.9\"\n      ],\n      \"trailers\": {},\n      \"rawTrailers\": [],\n      \"aborted\": false,\n      \"upgrade\": false,\n      \"url\": \"/favicon.ico\",\n      \"method\": \"GET\",\n      \"statusCode\": null,\n      \"statusMessage\": null,\n      \"client\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": false,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.client]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 34018\n        },\n        \"timeout\": 0\n      },\n      \"_consuming\": false,\n      \"_dumped\": false,\n      \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n      \"baseUrl\": \"\",\n      \"originalUrl\": \"/favicon.ico\",\n      \"_parsedUrl\": {\n        \"protocol\": null,\n        \"slashes\": null,\n        \"auth\": null,\n        \"host\": null,\n        \"port\": null,\n        \"hostname\": null,\n        \"hash\": null,\n        \"search\": null,\n        \"query\": null,\n        \"pathname\": \"/favicon.ico\",\n        \"path\": \"/favicon.ico\",\n        \"href\": \"/favicon.ico\",\n        \"_raw\": \"/favicon.ico\"\n      },\n      \"params\": {},\n      \"query\": {},\n      \"res\": \"[Circular ~.res]\",\n      \"body\": {},\n      \"_startAt\": [\n        118516,\n        480589246\n      ],\n      \"_startTime\": \"2020-11-30T04:19:09.282Z\",\n      \"_remoteAddress\": \"::1\"\n    },\n    \"locals\": {},\n    \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n    \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n    \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n    \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n    \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n    \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n  },\n  \"body\": {},\n  \"_startAt\": [\n    118516,\n    480589246\n  ],\n  \"_startTime\": \"2020-11-30T04:19:09.282Z\",\n  \"_remoteAddress\": \"::1\",\n  \"statusCode\" \u001b[31m[1]\u001b[0m: null\n}\n\u001b[31m\n[1] \"statusCode\" must be one of [400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511]\u001b[0m","level":"error","service":"monkey"}
{"message":"{\n  \"_readableState\": {\n    \"objectMode\": false,\n    \"highWaterMark\": 16384,\n    \"buffer\": {\n      \"head\": null,\n      \"tail\": null,\n      \"length\": 0\n    },\n    \"length\": 0,\n    \"pipes\": [],\n    \"flowing\": null,\n    \"ended\": false,\n    \"endEmitted\": false,\n    \"reading\": false,\n    \"sync\": true,\n    \"needReadable\": false,\n    \"emittedReadable\": false,\n    \"readableListening\": false,\n    \"resumeScheduled\": false,\n    \"errorEmitted\": false,\n    \"emitClose\": true,\n    \"autoDestroy\": false,\n    \"destroyed\": false,\n    \"errored\": null,\n    \"closed\": false,\n    \"closeEmitted\": false,\n    \"defaultEncoding\": \"utf8\",\n    \"awaitDrainWriters\": null,\n    \"multiAwaitDrain\": false,\n    \"readingMore\": true,\n    \"decoder\": null,\n    \"encoding\": null\n  },\n  \"_events\": {\n    \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n  },\n  \"_eventsCount\": 1,\n  \"socket\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": true,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.socket]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"cache-control\": \"max-age=0\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Cache-Control\",\n          \"max-age=0\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.socket]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.socket.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118558,\n          374792977\n        ],\n        \"_startTime\": \"2020-11-30T04:19:51.176Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.socket]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"cache-control\": \"max-age=0\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Cache-Control\",\n          \"max-age=0\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.socket._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118558,\n          374792977\n        ],\n        \"_startTime\": \"2020-11-30T04:19:51.176Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 34028\n    }\n  },\n  \"httpVersionMajor\": 1,\n  \"httpVersionMinor\": 1,\n  \"httpVersion\": \"1.1\",\n  \"complete\": false,\n  \"headers\": {\n    \"host\": \"localhost:3000\",\n    \"connection\": \"keep-alive\",\n    \"cache-control\": \"max-age=0\",\n    \"upgrade-insecure-requests\": \"1\",\n    \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n    \"sec-fetch-site\": \"none\",\n    \"sec-fetch-mode\": \"navigate\",\n    \"sec-fetch-user\": \"?1\",\n    \"sec-fetch-dest\": \"document\",\n    \"accept-encoding\": \"gzip, deflate, br\",\n    \"accept-language\": \"en-US,en;q=0.9\"\n  },\n  \"rawHeaders\": [\n    \"Host\",\n    \"localhost:3000\",\n    \"Connection\",\n    \"keep-alive\",\n    \"Cache-Control\",\n    \"max-age=0\",\n    \"Upgrade-Insecure-Requests\",\n    \"1\",\n    \"User-Agent\",\n    \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"Accept\",\n    \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n    \"Sec-Fetch-Site\",\n    \"none\",\n    \"Sec-Fetch-Mode\",\n    \"navigate\",\n    \"Sec-Fetch-User\",\n    \"?1\",\n    \"Sec-Fetch-Dest\",\n    \"document\",\n    \"Accept-Encoding\",\n    \"gzip, deflate, br\",\n    \"Accept-Language\",\n    \"en-US,en;q=0.9\"\n  ],\n  \"trailers\": {},\n  \"rawTrailers\": [],\n  \"aborted\": false,\n  \"upgrade\": false,\n  \"url\": \"/\",\n  \"method\": \"GET\",\n  \"statusMessage\": null,\n  \"client\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": true,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.client]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"cache-control\": \"max-age=0\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Cache-Control\",\n          \"max-age=0\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.client]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.client.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118558,\n          374792977\n        ],\n        \"_startTime\": \"2020-11-30T04:19:51.176Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.client]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"cache-control\": \"max-age=0\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Cache-Control\",\n          \"max-age=0\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.client._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118558,\n          374792977\n        ],\n        \"_startTime\": \"2020-11-30T04:19:51.176Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 34028\n    }\n  },\n  \"_consuming\": false,\n  \"_dumped\": false,\n  \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n  \"baseUrl\": \"\",\n  \"originalUrl\": \"/\",\n  \"_parsedUrl\": {\n    \"protocol\": null,\n    \"slashes\": null,\n    \"auth\": null,\n    \"host\": null,\n    \"port\": null,\n    \"hostname\": null,\n    \"hash\": null,\n    \"search\": null,\n    \"query\": null,\n    \"pathname\": \"/\",\n    \"path\": \"/\",\n    \"href\": \"/\",\n    \"_raw\": \"/\"\n  },\n  \"params\": {},\n  \"query\": {},\n  \"res\": {\n    \"_events\": {\n      \"finish\": [\n        function () { [native code] },\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n    },\n    \"_eventsCount\": 2,\n    \"outputData\": [],\n    \"outputSize\": 0,\n    \"writable\": true,\n    \"destroyed\": false,\n    \"_last\": false,\n    \"chunkedEncoding\": false,\n    \"shouldKeepAlive\": true,\n    \"_defaultKeepAlive\": true,\n    \"useChunkedEncodingByDefault\": true,\n    \"sendDate\": true,\n    \"_removedConnection\": false,\n    \"_removedContLen\": false,\n    \"_removedTE\": false,\n    \"_contentLength\": null,\n    \"_hasBody\": true,\n    \"_trailer\": \"\",\n    \"finished\": false,\n    \"_headerSent\": false,\n    \"socket\": {\n      \"connecting\": false,\n      \"_hadError\": false,\n      \"_parent\": null,\n      \"_host\": null,\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": true,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": true,\n        \"sync\": false,\n        \"needReadable\": true,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": false,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": [\n          function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n          function () { [native code] }\n        ],\n        \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n        \"data\": function () { [native code] },\n        \"error\": [\n          function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"close\": [\n          function () { [native code] },\n          function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"drain\": function () { [native code] },\n        \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n        \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n      },\n      \"_eventsCount\": 8,\n      \"_writableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"finalCalled\": false,\n        \"needDrain\": false,\n        \"ending\": false,\n        \"ended\": false,\n        \"finished\": false,\n        \"destroyed\": false,\n        \"decodeStrings\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"length\": 0,\n        \"writing\": false,\n        \"corked\": 0,\n        \"sync\": true,\n        \"bufferProcessing\": false,\n        \"onwrite\": function () { [native code] },\n        \"writecb\": null,\n        \"writelen\": 0,\n        \"afterWriteTickInfo\": null,\n        \"buffered\": [],\n        \"bufferedIndex\": 0,\n        \"allBuffers\": true,\n        \"allNoop\": true,\n        \"pendingcb\": 0,\n        \"prefinished\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false\n      },\n      \"allowHalfOpen\": true,\n      \"_sockname\": null,\n      \"_pendingData\": null,\n      \"_pendingEncoding\": \"\",\n      \"server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"_server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"parser\": {\n        \"0\": function () { [native code] },\n        \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n        \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n        \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n        \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n        \"5\": function () { [native code] },\n        \"6\": function () { [native code] },\n        \"_headers\": [],\n        \"_url\": \"\",\n        \"socket\": \"[Circular ~.res.socket]\",\n        \"incoming\": {\n          \"_readableState\": {\n            \"objectMode\": false,\n            \"highWaterMark\": 16384,\n            \"buffer\": {\n              \"head\": null,\n              \"tail\": null,\n              \"length\": 0\n            },\n            \"length\": 0,\n            \"pipes\": [],\n            \"flowing\": null,\n            \"ended\": false,\n            \"endEmitted\": false,\n            \"reading\": false,\n            \"sync\": true,\n            \"needReadable\": false,\n            \"emittedReadable\": false,\n            \"readableListening\": false,\n            \"resumeScheduled\": false,\n            \"errorEmitted\": false,\n            \"emitClose\": true,\n            \"autoDestroy\": false,\n            \"destroyed\": false,\n            \"errored\": null,\n            \"closed\": false,\n            \"closeEmitted\": false,\n            \"defaultEncoding\": \"utf8\",\n            \"awaitDrainWriters\": null,\n            \"multiAwaitDrain\": false,\n            \"readingMore\": true,\n            \"decoder\": null,\n            \"encoding\": null\n          },\n          \"_events\": {\n            \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n          },\n          \"_eventsCount\": 1,\n          \"socket\": \"[Circular ~.res.socket]\",\n          \"httpVersionMajor\": 1,\n          \"httpVersionMinor\": 1,\n          \"httpVersion\": \"1.1\",\n          \"complete\": false,\n          \"headers\": {\n            \"host\": \"localhost:3000\",\n            \"connection\": \"keep-alive\",\n            \"cache-control\": \"max-age=0\",\n            \"upgrade-insecure-requests\": \"1\",\n            \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n            \"sec-fetch-site\": \"none\",\n            \"sec-fetch-mode\": \"navigate\",\n            \"sec-fetch-user\": \"?1\",\n            \"sec-fetch-dest\": \"document\",\n            \"accept-encoding\": \"gzip, deflate, br\",\n            \"accept-language\": \"en-US,en;q=0.9\"\n          },\n          \"rawHeaders\": [\n            \"Host\",\n            \"localhost:3000\",\n            \"Connection\",\n            \"keep-alive\",\n            \"Cache-Control\",\n            \"max-age=0\",\n            \"Upgrade-Insecure-Requests\",\n            \"1\",\n            \"User-Agent\",\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"Accept\",\n            \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n            \"Sec-Fetch-Site\",\n            \"none\",\n            \"Sec-Fetch-Mode\",\n            \"navigate\",\n            \"Sec-Fetch-User\",\n            \"?1\",\n            \"Sec-Fetch-Dest\",\n            \"document\",\n            \"Accept-Encoding\",\n            \"gzip, deflate, br\",\n            \"Accept-Language\",\n            \"en-US,en;q=0.9\"\n          ],\n          \"trailers\": {},\n          \"rawTrailers\": [],\n          \"aborted\": false,\n          \"upgrade\": false,\n          \"url\": \"/\",\n          \"method\": \"GET\",\n          \"statusCode\": null,\n          \"statusMessage\": null,\n          \"client\": \"[Circular ~.res.socket]\",\n          \"_consuming\": false,\n          \"_dumped\": false,\n          \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n          \"baseUrl\": \"\",\n          \"originalUrl\": \"/\",\n          \"_parsedUrl\": {\n            \"protocol\": null,\n            \"slashes\": null,\n            \"auth\": null,\n            \"host\": null,\n            \"port\": null,\n            \"hostname\": null,\n            \"hash\": null,\n            \"search\": null,\n            \"query\": null,\n            \"pathname\": \"/\",\n            \"path\": \"/\",\n            \"href\": \"/\",\n            \"_raw\": \"/\"\n          },\n          \"params\": {},\n          \"query\": {},\n          \"res\": \"[Circular ~.res]\",\n          \"body\": {},\n          \"_startAt\": [\n            118558,\n            374792977\n          ],\n          \"_startTime\": \"2020-11-30T04:19:51.176Z\",\n          \"_remoteAddress\": \"::1\"\n        },\n        \"outgoing\": null,\n        \"maxHeaderPairs\": 2000,\n        \"_consumed\": true,\n        \"onIncoming\": function () { [native code] }\n      },\n      \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"_paused\": false,\n      \"_httpMessage\": \"[Circular ~.res]\",\n      \"_peername\": {\n        \"address\": \"::1\",\n        \"family\": \"IPv6\",\n        \"port\": 34028\n      }\n    },\n    \"_header\": null,\n    \"_keepAliveTimeout\": 5000,\n    \"_onPendingData\": function () { [native code] },\n    \"_sent100\": false,\n    \"_expect_continue\": false,\n    \"req\": {\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": null,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": false,\n        \"sync\": true,\n        \"needReadable\": false,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": true,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": true,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n      },\n      \"_eventsCount\": 1,\n      \"socket\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": true,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.socket]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 34028\n        }\n      },\n      \"httpVersionMajor\": 1,\n      \"httpVersionMinor\": 1,\n      \"httpVersion\": \"1.1\",\n      \"complete\": false,\n      \"headers\": {\n        \"host\": \"localhost:3000\",\n        \"connection\": \"keep-alive\",\n        \"cache-control\": \"max-age=0\",\n        \"upgrade-insecure-requests\": \"1\",\n        \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n        \"sec-fetch-site\": \"none\",\n        \"sec-fetch-mode\": \"navigate\",\n        \"sec-fetch-user\": \"?1\",\n        \"sec-fetch-dest\": \"document\",\n        \"accept-encoding\": \"gzip, deflate, br\",\n        \"accept-language\": \"en-US,en;q=0.9\"\n      },\n      \"rawHeaders\": [\n        \"Host\",\n        \"localhost:3000\",\n        \"Connection\",\n        \"keep-alive\",\n        \"Cache-Control\",\n        \"max-age=0\",\n        \"Upgrade-Insecure-Requests\",\n        \"1\",\n        \"User-Agent\",\n        \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"Accept\",\n        \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n        \"Sec-Fetch-Site\",\n        \"none\",\n        \"Sec-Fetch-Mode\",\n        \"navigate\",\n        \"Sec-Fetch-User\",\n        \"?1\",\n        \"Sec-Fetch-Dest\",\n        \"document\",\n        \"Accept-Encoding\",\n        \"gzip, deflate, br\",\n        \"Accept-Language\",\n        \"en-US,en;q=0.9\"\n      ],\n      \"trailers\": {},\n      \"rawTrailers\": [],\n      \"aborted\": false,\n      \"upgrade\": false,\n      \"url\": \"/\",\n      \"method\": \"GET\",\n      \"statusCode\": null,\n      \"statusMessage\": null,\n      \"client\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": true,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.client]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 34028\n        }\n      },\n      \"_consuming\": false,\n      \"_dumped\": false,\n      \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n      \"baseUrl\": \"\",\n      \"originalUrl\": \"/\",\n      \"_parsedUrl\": {\n        \"protocol\": null,\n        \"slashes\": null,\n        \"auth\": null,\n        \"host\": null,\n        \"port\": null,\n        \"hostname\": null,\n        \"hash\": null,\n        \"search\": null,\n        \"query\": null,\n        \"pathname\": \"/\",\n        \"path\": \"/\",\n        \"href\": \"/\",\n        \"_raw\": \"/\"\n      },\n      \"params\": {},\n      \"query\": {},\n      \"res\": \"[Circular ~.res]\",\n      \"body\": {},\n      \"_startAt\": [\n        118558,\n        374792977\n      ],\n      \"_startTime\": \"2020-11-30T04:19:51.176Z\",\n      \"_remoteAddress\": \"::1\"\n    },\n    \"locals\": {},\n    \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n    \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n    \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n    \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n    \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n    \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n  },\n  \"body\": {},\n  \"_startAt\": [\n    118558,\n    374792977\n  ],\n  \"_startTime\": \"2020-11-30T04:19:51.176Z\",\n  \"_remoteAddress\": \"::1\",\n  \"statusCode\" \u001b[31m[1]\u001b[0m: null\n}\n\u001b[31m\n[1] \"statusCode\" must be one of [400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511]\u001b[0m","level":"error","service":"monkey"}
{"message":"{\n  \"_readableState\": {\n    \"objectMode\": false,\n    \"highWaterMark\": 16384,\n    \"buffer\": {\n      \"head\": null,\n      \"tail\": null,\n      \"length\": 0\n    },\n    \"length\": 0,\n    \"pipes\": [],\n    \"flowing\": null,\n    \"ended\": false,\n    \"endEmitted\": false,\n    \"reading\": false,\n    \"sync\": true,\n    \"needReadable\": false,\n    \"emittedReadable\": false,\n    \"readableListening\": false,\n    \"resumeScheduled\": false,\n    \"errorEmitted\": false,\n    \"emitClose\": true,\n    \"autoDestroy\": false,\n    \"destroyed\": false,\n    \"errored\": null,\n    \"closed\": false,\n    \"closeEmitted\": false,\n    \"defaultEncoding\": \"utf8\",\n    \"awaitDrainWriters\": null,\n    \"multiAwaitDrain\": false,\n    \"readingMore\": true,\n    \"decoder\": null,\n    \"encoding\": null\n  },\n  \"_events\": {\n    \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n  },\n  \"_eventsCount\": 1,\n  \"socket\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": false,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.socket]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"pragma\": \"no-cache\",\n          \"cache-control\": \"no-cache\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Pragma\",\n          \"no-cache\",\n          \"Cache-Control\",\n          \"no-cache\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.socket]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.socket.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118558,\n          521551299\n        ],\n        \"_startTime\": \"2020-11-30T04:19:51.323Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.socket]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"pragma\": \"no-cache\",\n          \"cache-control\": \"no-cache\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Pragma\",\n          \"no-cache\",\n          \"Cache-Control\",\n          \"no-cache\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.socket._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118558,\n          521551299\n        ],\n        \"_startTime\": \"2020-11-30T04:19:51.323Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 34028\n    },\n    \"timeout\": 0\n  },\n  \"httpVersionMajor\": 1,\n  \"httpVersionMinor\": 1,\n  \"httpVersion\": \"1.1\",\n  \"complete\": false,\n  \"headers\": {\n    \"host\": \"localhost:3000\",\n    \"connection\": \"keep-alive\",\n    \"pragma\": \"no-cache\",\n    \"cache-control\": \"no-cache\",\n    \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n    \"sec-fetch-site\": \"same-origin\",\n    \"sec-fetch-mode\": \"no-cors\",\n    \"sec-fetch-dest\": \"image\",\n    \"accept-encoding\": \"gzip, deflate, br\",\n    \"accept-language\": \"en-US,en;q=0.9\"\n  },\n  \"rawHeaders\": [\n    \"Host\",\n    \"localhost:3000\",\n    \"Connection\",\n    \"keep-alive\",\n    \"Pragma\",\n    \"no-cache\",\n    \"Cache-Control\",\n    \"no-cache\",\n    \"User-Agent\",\n    \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"Accept\",\n    \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n    \"Sec-Fetch-Site\",\n    \"same-origin\",\n    \"Sec-Fetch-Mode\",\n    \"no-cors\",\n    \"Sec-Fetch-Dest\",\n    \"image\",\n    \"Accept-Encoding\",\n    \"gzip, deflate, br\",\n    \"Accept-Language\",\n    \"en-US,en;q=0.9\"\n  ],\n  \"trailers\": {},\n  \"rawTrailers\": [],\n  \"aborted\": false,\n  \"upgrade\": false,\n  \"url\": \"/favicon.ico\",\n  \"method\": \"GET\",\n  \"statusMessage\": null,\n  \"client\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": false,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.client]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"pragma\": \"no-cache\",\n          \"cache-control\": \"no-cache\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Pragma\",\n          \"no-cache\",\n          \"Cache-Control\",\n          \"no-cache\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.client]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.client.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118558,\n          521551299\n        ],\n        \"_startTime\": \"2020-11-30T04:19:51.323Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.client]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"pragma\": \"no-cache\",\n          \"cache-control\": \"no-cache\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Pragma\",\n          \"no-cache\",\n          \"Cache-Control\",\n          \"no-cache\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.client._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118558,\n          521551299\n        ],\n        \"_startTime\": \"2020-11-30T04:19:51.323Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 34028\n    },\n    \"timeout\": 0\n  },\n  \"_consuming\": false,\n  \"_dumped\": false,\n  \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n  \"baseUrl\": \"\",\n  \"originalUrl\": \"/favicon.ico\",\n  \"_parsedUrl\": {\n    \"protocol\": null,\n    \"slashes\": null,\n    \"auth\": null,\n    \"host\": null,\n    \"port\": null,\n    \"hostname\": null,\n    \"hash\": null,\n    \"search\": null,\n    \"query\": null,\n    \"pathname\": \"/favicon.ico\",\n    \"path\": \"/favicon.ico\",\n    \"href\": \"/favicon.ico\",\n    \"_raw\": \"/favicon.ico\"\n  },\n  \"params\": {},\n  \"query\": {},\n  \"res\": {\n    \"_events\": {\n      \"finish\": [\n        function () { [native code] },\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n    },\n    \"_eventsCount\": 2,\n    \"outputData\": [],\n    \"outputSize\": 0,\n    \"writable\": true,\n    \"destroyed\": false,\n    \"_last\": false,\n    \"chunkedEncoding\": false,\n    \"shouldKeepAlive\": true,\n    \"_defaultKeepAlive\": true,\n    \"useChunkedEncodingByDefault\": true,\n    \"sendDate\": true,\n    \"_removedConnection\": false,\n    \"_removedContLen\": false,\n    \"_removedTE\": false,\n    \"_contentLength\": null,\n    \"_hasBody\": true,\n    \"_trailer\": \"\",\n    \"finished\": false,\n    \"_headerSent\": false,\n    \"socket\": {\n      \"connecting\": false,\n      \"_hadError\": false,\n      \"_parent\": null,\n      \"_host\": null,\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": true,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": true,\n        \"sync\": false,\n        \"needReadable\": true,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": false,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": [\n          function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n          function () { [native code] }\n        ],\n        \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n        \"data\": function () { [native code] },\n        \"error\": [\n          function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"close\": [\n          function () { [native code] },\n          function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"drain\": function () { [native code] },\n        \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n        \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n      },\n      \"_eventsCount\": 8,\n      \"_writableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"finalCalled\": false,\n        \"needDrain\": false,\n        \"ending\": false,\n        \"ended\": false,\n        \"finished\": false,\n        \"destroyed\": false,\n        \"decodeStrings\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"length\": 0,\n        \"writing\": false,\n        \"corked\": 0,\n        \"sync\": false,\n        \"bufferProcessing\": false,\n        \"onwrite\": function () { [native code] },\n        \"writecb\": null,\n        \"writelen\": 0,\n        \"afterWriteTickInfo\": null,\n        \"buffered\": [],\n        \"bufferedIndex\": 0,\n        \"allBuffers\": true,\n        \"allNoop\": true,\n        \"pendingcb\": 0,\n        \"prefinished\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false\n      },\n      \"allowHalfOpen\": true,\n      \"_sockname\": null,\n      \"_pendingData\": null,\n      \"_pendingEncoding\": \"\",\n      \"server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"_server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"parser\": {\n        \"0\": function () { [native code] },\n        \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n        \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n        \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n        \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n        \"5\": function () { [native code] },\n        \"6\": function () { [native code] },\n        \"_headers\": [],\n        \"_url\": \"\",\n        \"socket\": \"[Circular ~.res.socket]\",\n        \"incoming\": {\n          \"_readableState\": {\n            \"objectMode\": false,\n            \"highWaterMark\": 16384,\n            \"buffer\": {\n              \"head\": null,\n              \"tail\": null,\n              \"length\": 0\n            },\n            \"length\": 0,\n            \"pipes\": [],\n            \"flowing\": null,\n            \"ended\": false,\n            \"endEmitted\": false,\n            \"reading\": false,\n            \"sync\": true,\n            \"needReadable\": false,\n            \"emittedReadable\": false,\n            \"readableListening\": false,\n            \"resumeScheduled\": false,\n            \"errorEmitted\": false,\n            \"emitClose\": true,\n            \"autoDestroy\": false,\n            \"destroyed\": false,\n            \"errored\": null,\n            \"closed\": false,\n            \"closeEmitted\": false,\n            \"defaultEncoding\": \"utf8\",\n            \"awaitDrainWriters\": null,\n            \"multiAwaitDrain\": false,\n            \"readingMore\": true,\n            \"decoder\": null,\n            \"encoding\": null\n          },\n          \"_events\": {\n            \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n          },\n          \"_eventsCount\": 1,\n          \"socket\": \"[Circular ~.res.socket]\",\n          \"httpVersionMajor\": 1,\n          \"httpVersionMinor\": 1,\n          \"httpVersion\": \"1.1\",\n          \"complete\": false,\n          \"headers\": {\n            \"host\": \"localhost:3000\",\n            \"connection\": \"keep-alive\",\n            \"pragma\": \"no-cache\",\n            \"cache-control\": \"no-cache\",\n            \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n            \"sec-fetch-site\": \"same-origin\",\n            \"sec-fetch-mode\": \"no-cors\",\n            \"sec-fetch-dest\": \"image\",\n            \"accept-encoding\": \"gzip, deflate, br\",\n            \"accept-language\": \"en-US,en;q=0.9\"\n          },\n          \"rawHeaders\": [\n            \"Host\",\n            \"localhost:3000\",\n            \"Connection\",\n            \"keep-alive\",\n            \"Pragma\",\n            \"no-cache\",\n            \"Cache-Control\",\n            \"no-cache\",\n            \"User-Agent\",\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"Accept\",\n            \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n            \"Sec-Fetch-Site\",\n            \"same-origin\",\n            \"Sec-Fetch-Mode\",\n            \"no-cors\",\n            \"Sec-Fetch-Dest\",\n            \"image\",\n            \"Accept-Encoding\",\n            \"gzip, deflate, br\",\n            \"Accept-Language\",\n            \"en-US,en;q=0.9\"\n          ],\n          \"trailers\": {},\n          \"rawTrailers\": [],\n          \"aborted\": false,\n          \"upgrade\": false,\n          \"url\": \"/favicon.ico\",\n          \"method\": \"GET\",\n          \"statusCode\": null,\n          \"statusMessage\": null,\n          \"client\": \"[Circular ~.res.socket]\",\n          \"_consuming\": false,\n          \"_dumped\": false,\n          \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n          \"baseUrl\": \"\",\n          \"originalUrl\": \"/favicon.ico\",\n          \"_parsedUrl\": {\n            \"protocol\": null,\n            \"slashes\": null,\n            \"auth\": null,\n            \"host\": null,\n            \"port\": null,\n            \"hostname\": null,\n            \"hash\": null,\n            \"search\": null,\n            \"query\": null,\n            \"pathname\": \"/favicon.ico\",\n            \"path\": \"/favicon.ico\",\n            \"href\": \"/favicon.ico\",\n            \"_raw\": \"/favicon.ico\"\n          },\n          \"params\": {},\n          \"query\": {},\n          \"res\": \"[Circular ~.res]\",\n          \"body\": {},\n          \"_startAt\": [\n            118558,\n            521551299\n          ],\n          \"_startTime\": \"2020-11-30T04:19:51.323Z\",\n          \"_remoteAddress\": \"::1\"\n        },\n        \"outgoing\": null,\n        \"maxHeaderPairs\": 2000,\n        \"_consumed\": true,\n        \"onIncoming\": function () { [native code] }\n      },\n      \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"_paused\": false,\n      \"_httpMessage\": \"[Circular ~.res]\",\n      \"_peername\": {\n        \"address\": \"::1\",\n        \"family\": \"IPv6\",\n        \"port\": 34028\n      },\n      \"timeout\": 0\n    },\n    \"_header\": null,\n    \"_keepAliveTimeout\": 5000,\n    \"_onPendingData\": function () { [native code] },\n    \"_sent100\": false,\n    \"_expect_continue\": false,\n    \"req\": {\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": null,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": false,\n        \"sync\": true,\n        \"needReadable\": false,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": true,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": true,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n      },\n      \"_eventsCount\": 1,\n      \"socket\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": false,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.socket]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 34028\n        },\n        \"timeout\": 0\n      },\n      \"httpVersionMajor\": 1,\n      \"httpVersionMinor\": 1,\n      \"httpVersion\": \"1.1\",\n      \"complete\": false,\n      \"headers\": {\n        \"host\": \"localhost:3000\",\n        \"connection\": \"keep-alive\",\n        \"pragma\": \"no-cache\",\n        \"cache-control\": \"no-cache\",\n        \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n        \"sec-fetch-site\": \"same-origin\",\n        \"sec-fetch-mode\": \"no-cors\",\n        \"sec-fetch-dest\": \"image\",\n        \"accept-encoding\": \"gzip, deflate, br\",\n        \"accept-language\": \"en-US,en;q=0.9\"\n      },\n      \"rawHeaders\": [\n        \"Host\",\n        \"localhost:3000\",\n        \"Connection\",\n        \"keep-alive\",\n        \"Pragma\",\n        \"no-cache\",\n        \"Cache-Control\",\n        \"no-cache\",\n        \"User-Agent\",\n        \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"Accept\",\n        \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n        \"Sec-Fetch-Site\",\n        \"same-origin\",\n        \"Sec-Fetch-Mode\",\n        \"no-cors\",\n        \"Sec-Fetch-Dest\",\n        \"image\",\n        \"Accept-Encoding\",\n        \"gzip, deflate, br\",\n        \"Accept-Language\",\n        \"en-US,en;q=0.9\"\n      ],\n      \"trailers\": {},\n      \"rawTrailers\": [],\n      \"aborted\": false,\n      \"upgrade\": false,\n      \"url\": \"/favicon.ico\",\n      \"method\": \"GET\",\n      \"statusCode\": null,\n      \"statusMessage\": null,\n      \"client\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": false,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.client]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 34028\n        },\n        \"timeout\": 0\n      },\n      \"_consuming\": false,\n      \"_dumped\": false,\n      \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n      \"baseUrl\": \"\",\n      \"originalUrl\": \"/favicon.ico\",\n      \"_parsedUrl\": {\n        \"protocol\": null,\n        \"slashes\": null,\n        \"auth\": null,\n        \"host\": null,\n        \"port\": null,\n        \"hostname\": null,\n        \"hash\": null,\n        \"search\": null,\n        \"query\": null,\n        \"pathname\": \"/favicon.ico\",\n        \"path\": \"/favicon.ico\",\n        \"href\": \"/favicon.ico\",\n        \"_raw\": \"/favicon.ico\"\n      },\n      \"params\": {},\n      \"query\": {},\n      \"res\": \"[Circular ~.res]\",\n      \"body\": {},\n      \"_startAt\": [\n        118558,\n        521551299\n      ],\n      \"_startTime\": \"2020-11-30T04:19:51.323Z\",\n      \"_remoteAddress\": \"::1\"\n    },\n    \"locals\": {},\n    \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n    \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n    \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n    \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n    \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n    \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n  },\n  \"body\": {},\n  \"_startAt\": [\n    118558,\n    521551299\n  ],\n  \"_startTime\": \"2020-11-30T04:19:51.323Z\",\n  \"_remoteAddress\": \"::1\",\n  \"statusCode\" \u001b[31m[1]\u001b[0m: null\n}\n\u001b[31m\n[1] \"statusCode\" must be one of [400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511]\u001b[0m","level":"error","service":"monkey"}
{"message":"{\n  \"_readableState\": {\n    \"objectMode\": false,\n    \"highWaterMark\": 16384,\n    \"buffer\": {\n      \"head\": null,\n      \"tail\": null,\n      \"length\": 0\n    },\n    \"length\": 0,\n    \"pipes\": [],\n    \"flowing\": null,\n    \"ended\": false,\n    \"endEmitted\": false,\n    \"reading\": false,\n    \"sync\": true,\n    \"needReadable\": false,\n    \"emittedReadable\": false,\n    \"readableListening\": false,\n    \"resumeScheduled\": false,\n    \"errorEmitted\": false,\n    \"emitClose\": true,\n    \"autoDestroy\": false,\n    \"destroyed\": false,\n    \"errored\": null,\n    \"closed\": false,\n    \"closeEmitted\": false,\n    \"defaultEncoding\": \"utf8\",\n    \"awaitDrainWriters\": null,\n    \"multiAwaitDrain\": false,\n    \"readingMore\": true,\n    \"decoder\": null,\n    \"encoding\": null\n  },\n  \"_events\": {\n    \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n  },\n  \"_eventsCount\": 1,\n  \"socket\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": true,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.socket]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"cache-control\": \"max-age=0\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Cache-Control\",\n          \"max-age=0\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.socket]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.socket.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118643,\n          963127458\n        ],\n        \"_startTime\": \"2020-11-30T04:21:16.764Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.socket]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"cache-control\": \"max-age=0\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Cache-Control\",\n          \"max-age=0\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.socket._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118643,\n          963127458\n        ],\n        \"_startTime\": \"2020-11-30T04:21:16.764Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 34038\n    }\n  },\n  \"httpVersionMajor\": 1,\n  \"httpVersionMinor\": 1,\n  \"httpVersion\": \"1.1\",\n  \"complete\": false,\n  \"headers\": {\n    \"host\": \"localhost:3000\",\n    \"connection\": \"keep-alive\",\n    \"cache-control\": \"max-age=0\",\n    \"upgrade-insecure-requests\": \"1\",\n    \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n    \"sec-fetch-site\": \"none\",\n    \"sec-fetch-mode\": \"navigate\",\n    \"sec-fetch-user\": \"?1\",\n    \"sec-fetch-dest\": \"document\",\n    \"accept-encoding\": \"gzip, deflate, br\",\n    \"accept-language\": \"en-US,en;q=0.9\"\n  },\n  \"rawHeaders\": [\n    \"Host\",\n    \"localhost:3000\",\n    \"Connection\",\n    \"keep-alive\",\n    \"Cache-Control\",\n    \"max-age=0\",\n    \"Upgrade-Insecure-Requests\",\n    \"1\",\n    \"User-Agent\",\n    \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"Accept\",\n    \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n    \"Sec-Fetch-Site\",\n    \"none\",\n    \"Sec-Fetch-Mode\",\n    \"navigate\",\n    \"Sec-Fetch-User\",\n    \"?1\",\n    \"Sec-Fetch-Dest\",\n    \"document\",\n    \"Accept-Encoding\",\n    \"gzip, deflate, br\",\n    \"Accept-Language\",\n    \"en-US,en;q=0.9\"\n  ],\n  \"trailers\": {},\n  \"rawTrailers\": [],\n  \"aborted\": false,\n  \"upgrade\": false,\n  \"url\": \"/\",\n  \"method\": \"GET\",\n  \"statusMessage\": null,\n  \"client\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": true,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.client]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"cache-control\": \"max-age=0\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Cache-Control\",\n          \"max-age=0\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.client]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.client.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118643,\n          963127458\n        ],\n        \"_startTime\": \"2020-11-30T04:21:16.764Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.client]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"cache-control\": \"max-age=0\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Cache-Control\",\n          \"max-age=0\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.client._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118643,\n          963127458\n        ],\n        \"_startTime\": \"2020-11-30T04:21:16.764Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 34038\n    }\n  },\n  \"_consuming\": false,\n  \"_dumped\": false,\n  \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n  \"baseUrl\": \"\",\n  \"originalUrl\": \"/\",\n  \"_parsedUrl\": {\n    \"protocol\": null,\n    \"slashes\": null,\n    \"auth\": null,\n    \"host\": null,\n    \"port\": null,\n    \"hostname\": null,\n    \"hash\": null,\n    \"search\": null,\n    \"query\": null,\n    \"pathname\": \"/\",\n    \"path\": \"/\",\n    \"href\": \"/\",\n    \"_raw\": \"/\"\n  },\n  \"params\": {},\n  \"query\": {},\n  \"res\": {\n    \"_events\": {\n      \"finish\": [\n        function () { [native code] },\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n    },\n    \"_eventsCount\": 2,\n    \"outputData\": [],\n    \"outputSize\": 0,\n    \"writable\": true,\n    \"destroyed\": false,\n    \"_last\": false,\n    \"chunkedEncoding\": false,\n    \"shouldKeepAlive\": true,\n    \"_defaultKeepAlive\": true,\n    \"useChunkedEncodingByDefault\": true,\n    \"sendDate\": true,\n    \"_removedConnection\": false,\n    \"_removedContLen\": false,\n    \"_removedTE\": false,\n    \"_contentLength\": null,\n    \"_hasBody\": true,\n    \"_trailer\": \"\",\n    \"finished\": false,\n    \"_headerSent\": false,\n    \"socket\": {\n      \"connecting\": false,\n      \"_hadError\": false,\n      \"_parent\": null,\n      \"_host\": null,\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": true,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": true,\n        \"sync\": false,\n        \"needReadable\": true,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": false,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": [\n          function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n          function () { [native code] }\n        ],\n        \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n        \"data\": function () { [native code] },\n        \"error\": [\n          function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"close\": [\n          function () { [native code] },\n          function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"drain\": function () { [native code] },\n        \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n        \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n      },\n      \"_eventsCount\": 8,\n      \"_writableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"finalCalled\": false,\n        \"needDrain\": false,\n        \"ending\": false,\n        \"ended\": false,\n        \"finished\": false,\n        \"destroyed\": false,\n        \"decodeStrings\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"length\": 0,\n        \"writing\": false,\n        \"corked\": 0,\n        \"sync\": true,\n        \"bufferProcessing\": false,\n        \"onwrite\": function () { [native code] },\n        \"writecb\": null,\n        \"writelen\": 0,\n        \"afterWriteTickInfo\": null,\n        \"buffered\": [],\n        \"bufferedIndex\": 0,\n        \"allBuffers\": true,\n        \"allNoop\": true,\n        \"pendingcb\": 0,\n        \"prefinished\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false\n      },\n      \"allowHalfOpen\": true,\n      \"_sockname\": null,\n      \"_pendingData\": null,\n      \"_pendingEncoding\": \"\",\n      \"server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"_server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"parser\": {\n        \"0\": function () { [native code] },\n        \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n        \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n        \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n        \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n        \"5\": function () { [native code] },\n        \"6\": function () { [native code] },\n        \"_headers\": [],\n        \"_url\": \"\",\n        \"socket\": \"[Circular ~.res.socket]\",\n        \"incoming\": {\n          \"_readableState\": {\n            \"objectMode\": false,\n            \"highWaterMark\": 16384,\n            \"buffer\": {\n              \"head\": null,\n              \"tail\": null,\n              \"length\": 0\n            },\n            \"length\": 0,\n            \"pipes\": [],\n            \"flowing\": null,\n            \"ended\": false,\n            \"endEmitted\": false,\n            \"reading\": false,\n            \"sync\": true,\n            \"needReadable\": false,\n            \"emittedReadable\": false,\n            \"readableListening\": false,\n            \"resumeScheduled\": false,\n            \"errorEmitted\": false,\n            \"emitClose\": true,\n            \"autoDestroy\": false,\n            \"destroyed\": false,\n            \"errored\": null,\n            \"closed\": false,\n            \"closeEmitted\": false,\n            \"defaultEncoding\": \"utf8\",\n            \"awaitDrainWriters\": null,\n            \"multiAwaitDrain\": false,\n            \"readingMore\": true,\n            \"decoder\": null,\n            \"encoding\": null\n          },\n          \"_events\": {\n            \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n          },\n          \"_eventsCount\": 1,\n          \"socket\": \"[Circular ~.res.socket]\",\n          \"httpVersionMajor\": 1,\n          \"httpVersionMinor\": 1,\n          \"httpVersion\": \"1.1\",\n          \"complete\": false,\n          \"headers\": {\n            \"host\": \"localhost:3000\",\n            \"connection\": \"keep-alive\",\n            \"cache-control\": \"max-age=0\",\n            \"upgrade-insecure-requests\": \"1\",\n            \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n            \"sec-fetch-site\": \"none\",\n            \"sec-fetch-mode\": \"navigate\",\n            \"sec-fetch-user\": \"?1\",\n            \"sec-fetch-dest\": \"document\",\n            \"accept-encoding\": \"gzip, deflate, br\",\n            \"accept-language\": \"en-US,en;q=0.9\"\n          },\n          \"rawHeaders\": [\n            \"Host\",\n            \"localhost:3000\",\n            \"Connection\",\n            \"keep-alive\",\n            \"Cache-Control\",\n            \"max-age=0\",\n            \"Upgrade-Insecure-Requests\",\n            \"1\",\n            \"User-Agent\",\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"Accept\",\n            \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n            \"Sec-Fetch-Site\",\n            \"none\",\n            \"Sec-Fetch-Mode\",\n            \"navigate\",\n            \"Sec-Fetch-User\",\n            \"?1\",\n            \"Sec-Fetch-Dest\",\n            \"document\",\n            \"Accept-Encoding\",\n            \"gzip, deflate, br\",\n            \"Accept-Language\",\n            \"en-US,en;q=0.9\"\n          ],\n          \"trailers\": {},\n          \"rawTrailers\": [],\n          \"aborted\": false,\n          \"upgrade\": false,\n          \"url\": \"/\",\n          \"method\": \"GET\",\n          \"statusCode\": null,\n          \"statusMessage\": null,\n          \"client\": \"[Circular ~.res.socket]\",\n          \"_consuming\": false,\n          \"_dumped\": false,\n          \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n          \"baseUrl\": \"\",\n          \"originalUrl\": \"/\",\n          \"_parsedUrl\": {\n            \"protocol\": null,\n            \"slashes\": null,\n            \"auth\": null,\n            \"host\": null,\n            \"port\": null,\n            \"hostname\": null,\n            \"hash\": null,\n            \"search\": null,\n            \"query\": null,\n            \"pathname\": \"/\",\n            \"path\": \"/\",\n            \"href\": \"/\",\n            \"_raw\": \"/\"\n          },\n          \"params\": {},\n          \"query\": {},\n          \"res\": \"[Circular ~.res]\",\n          \"body\": {},\n          \"_startAt\": [\n            118643,\n            963127458\n          ],\n          \"_startTime\": \"2020-11-30T04:21:16.764Z\",\n          \"_remoteAddress\": \"::1\"\n        },\n        \"outgoing\": null,\n        \"maxHeaderPairs\": 2000,\n        \"_consumed\": true,\n        \"onIncoming\": function () { [native code] }\n      },\n      \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"_paused\": false,\n      \"_httpMessage\": \"[Circular ~.res]\",\n      \"_peername\": {\n        \"address\": \"::1\",\n        \"family\": \"IPv6\",\n        \"port\": 34038\n      }\n    },\n    \"_header\": null,\n    \"_keepAliveTimeout\": 5000,\n    \"_onPendingData\": function () { [native code] },\n    \"_sent100\": false,\n    \"_expect_continue\": false,\n    \"req\": {\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": null,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": false,\n        \"sync\": true,\n        \"needReadable\": false,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": true,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": true,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n      },\n      \"_eventsCount\": 1,\n      \"socket\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": true,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.socket]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 34038\n        }\n      },\n      \"httpVersionMajor\": 1,\n      \"httpVersionMinor\": 1,\n      \"httpVersion\": \"1.1\",\n      \"complete\": false,\n      \"headers\": {\n        \"host\": \"localhost:3000\",\n        \"connection\": \"keep-alive\",\n        \"cache-control\": \"max-age=0\",\n        \"upgrade-insecure-requests\": \"1\",\n        \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n        \"sec-fetch-site\": \"none\",\n        \"sec-fetch-mode\": \"navigate\",\n        \"sec-fetch-user\": \"?1\",\n        \"sec-fetch-dest\": \"document\",\n        \"accept-encoding\": \"gzip, deflate, br\",\n        \"accept-language\": \"en-US,en;q=0.9\"\n      },\n      \"rawHeaders\": [\n        \"Host\",\n        \"localhost:3000\",\n        \"Connection\",\n        \"keep-alive\",\n        \"Cache-Control\",\n        \"max-age=0\",\n        \"Upgrade-Insecure-Requests\",\n        \"1\",\n        \"User-Agent\",\n        \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"Accept\",\n        \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n        \"Sec-Fetch-Site\",\n        \"none\",\n        \"Sec-Fetch-Mode\",\n        \"navigate\",\n        \"Sec-Fetch-User\",\n        \"?1\",\n        \"Sec-Fetch-Dest\",\n        \"document\",\n        \"Accept-Encoding\",\n        \"gzip, deflate, br\",\n        \"Accept-Language\",\n        \"en-US,en;q=0.9\"\n      ],\n      \"trailers\": {},\n      \"rawTrailers\": [],\n      \"aborted\": false,\n      \"upgrade\": false,\n      \"url\": \"/\",\n      \"method\": \"GET\",\n      \"statusCode\": null,\n      \"statusMessage\": null,\n      \"client\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": true,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.client]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 34038\n        }\n      },\n      \"_consuming\": false,\n      \"_dumped\": false,\n      \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n      \"baseUrl\": \"\",\n      \"originalUrl\": \"/\",\n      \"_parsedUrl\": {\n        \"protocol\": null,\n        \"slashes\": null,\n        \"auth\": null,\n        \"host\": null,\n        \"port\": null,\n        \"hostname\": null,\n        \"hash\": null,\n        \"search\": null,\n        \"query\": null,\n        \"pathname\": \"/\",\n        \"path\": \"/\",\n        \"href\": \"/\",\n        \"_raw\": \"/\"\n      },\n      \"params\": {},\n      \"query\": {},\n      \"res\": \"[Circular ~.res]\",\n      \"body\": {},\n      \"_startAt\": [\n        118643,\n        963127458\n      ],\n      \"_startTime\": \"2020-11-30T04:21:16.764Z\",\n      \"_remoteAddress\": \"::1\"\n    },\n    \"locals\": {},\n    \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n    \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n    \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n    \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n    \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n    \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n  },\n  \"body\": {},\n  \"_startAt\": [\n    118643,\n    963127458\n  ],\n  \"_startTime\": \"2020-11-30T04:21:16.764Z\",\n  \"_remoteAddress\": \"::1\",\n  \"statusCode\" \u001b[31m[1]\u001b[0m: null\n}\n\u001b[31m\n[1] \"statusCode\" must be one of [400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511]\u001b[0m","level":"error","service":"monkey"}
{"message":"{\n  \"_readableState\": {\n    \"objectMode\": false,\n    \"highWaterMark\": 16384,\n    \"buffer\": {\n      \"head\": null,\n      \"tail\": null,\n      \"length\": 0\n    },\n    \"length\": 0,\n    \"pipes\": [],\n    \"flowing\": null,\n    \"ended\": false,\n    \"endEmitted\": false,\n    \"reading\": false,\n    \"sync\": true,\n    \"needReadable\": false,\n    \"emittedReadable\": false,\n    \"readableListening\": false,\n    \"resumeScheduled\": false,\n    \"errorEmitted\": false,\n    \"emitClose\": true,\n    \"autoDestroy\": false,\n    \"destroyed\": false,\n    \"errored\": null,\n    \"closed\": false,\n    \"closeEmitted\": false,\n    \"defaultEncoding\": \"utf8\",\n    \"awaitDrainWriters\": null,\n    \"multiAwaitDrain\": false,\n    \"readingMore\": true,\n    \"decoder\": null,\n    \"encoding\": null\n  },\n  \"_events\": {\n    \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n  },\n  \"_eventsCount\": 1,\n  \"socket\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": false,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.socket]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.socket]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.socket.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118644,\n          130451339\n        ],\n        \"_startTime\": \"2020-11-30T04:21:16.932Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.socket]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.socket._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118644,\n          130451339\n        ],\n        \"_startTime\": \"2020-11-30T04:21:16.932Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 34038\n    },\n    \"timeout\": 0\n  },\n  \"httpVersionMajor\": 1,\n  \"httpVersionMinor\": 1,\n  \"httpVersion\": \"1.1\",\n  \"complete\": false,\n  \"headers\": {\n    \"host\": \"localhost:3000\",\n    \"connection\": \"keep-alive\",\n    \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n    \"sec-fetch-site\": \"same-origin\",\n    \"sec-fetch-mode\": \"no-cors\",\n    \"sec-fetch-dest\": \"image\",\n    \"accept-encoding\": \"gzip, deflate, br\",\n    \"accept-language\": \"en-US,en;q=0.9\"\n  },\n  \"rawHeaders\": [\n    \"Host\",\n    \"localhost:3000\",\n    \"Connection\",\n    \"keep-alive\",\n    \"User-Agent\",\n    \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"Accept\",\n    \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n    \"Sec-Fetch-Site\",\n    \"same-origin\",\n    \"Sec-Fetch-Mode\",\n    \"no-cors\",\n    \"Sec-Fetch-Dest\",\n    \"image\",\n    \"Accept-Encoding\",\n    \"gzip, deflate, br\",\n    \"Accept-Language\",\n    \"en-US,en;q=0.9\"\n  ],\n  \"trailers\": {},\n  \"rawTrailers\": [],\n  \"aborted\": false,\n  \"upgrade\": false,\n  \"url\": \"/favicon.ico\",\n  \"method\": \"GET\",\n  \"statusMessage\": null,\n  \"client\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": false,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.client]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.client]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.client.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118644,\n          130451339\n        ],\n        \"_startTime\": \"2020-11-30T04:21:16.932Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.client]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.client._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118644,\n          130451339\n        ],\n        \"_startTime\": \"2020-11-30T04:21:16.932Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 34038\n    },\n    \"timeout\": 0\n  },\n  \"_consuming\": false,\n  \"_dumped\": false,\n  \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n  \"baseUrl\": \"\",\n  \"originalUrl\": \"/favicon.ico\",\n  \"_parsedUrl\": {\n    \"protocol\": null,\n    \"slashes\": null,\n    \"auth\": null,\n    \"host\": null,\n    \"port\": null,\n    \"hostname\": null,\n    \"hash\": null,\n    \"search\": null,\n    \"query\": null,\n    \"pathname\": \"/favicon.ico\",\n    \"path\": \"/favicon.ico\",\n    \"href\": \"/favicon.ico\",\n    \"_raw\": \"/favicon.ico\"\n  },\n  \"params\": {},\n  \"query\": {},\n  \"res\": {\n    \"_events\": {\n      \"finish\": [\n        function () { [native code] },\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n    },\n    \"_eventsCount\": 2,\n    \"outputData\": [],\n    \"outputSize\": 0,\n    \"writable\": true,\n    \"destroyed\": false,\n    \"_last\": false,\n    \"chunkedEncoding\": false,\n    \"shouldKeepAlive\": true,\n    \"_defaultKeepAlive\": true,\n    \"useChunkedEncodingByDefault\": true,\n    \"sendDate\": true,\n    \"_removedConnection\": false,\n    \"_removedContLen\": false,\n    \"_removedTE\": false,\n    \"_contentLength\": null,\n    \"_hasBody\": true,\n    \"_trailer\": \"\",\n    \"finished\": false,\n    \"_headerSent\": false,\n    \"socket\": {\n      \"connecting\": false,\n      \"_hadError\": false,\n      \"_parent\": null,\n      \"_host\": null,\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": true,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": true,\n        \"sync\": false,\n        \"needReadable\": true,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": false,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": [\n          function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n          function () { [native code] }\n        ],\n        \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n        \"data\": function () { [native code] },\n        \"error\": [\n          function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"close\": [\n          function () { [native code] },\n          function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"drain\": function () { [native code] },\n        \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n        \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n      },\n      \"_eventsCount\": 8,\n      \"_writableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"finalCalled\": false,\n        \"needDrain\": false,\n        \"ending\": false,\n        \"ended\": false,\n        \"finished\": false,\n        \"destroyed\": false,\n        \"decodeStrings\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"length\": 0,\n        \"writing\": false,\n        \"corked\": 0,\n        \"sync\": false,\n        \"bufferProcessing\": false,\n        \"onwrite\": function () { [native code] },\n        \"writecb\": null,\n        \"writelen\": 0,\n        \"afterWriteTickInfo\": null,\n        \"buffered\": [],\n        \"bufferedIndex\": 0,\n        \"allBuffers\": true,\n        \"allNoop\": true,\n        \"pendingcb\": 0,\n        \"prefinished\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false\n      },\n      \"allowHalfOpen\": true,\n      \"_sockname\": null,\n      \"_pendingData\": null,\n      \"_pendingEncoding\": \"\",\n      \"server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"_server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"parser\": {\n        \"0\": function () { [native code] },\n        \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n        \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n        \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n        \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n        \"5\": function () { [native code] },\n        \"6\": function () { [native code] },\n        \"_headers\": [],\n        \"_url\": \"\",\n        \"socket\": \"[Circular ~.res.socket]\",\n        \"incoming\": {\n          \"_readableState\": {\n            \"objectMode\": false,\n            \"highWaterMark\": 16384,\n            \"buffer\": {\n              \"head\": null,\n              \"tail\": null,\n              \"length\": 0\n            },\n            \"length\": 0,\n            \"pipes\": [],\n            \"flowing\": null,\n            \"ended\": false,\n            \"endEmitted\": false,\n            \"reading\": false,\n            \"sync\": true,\n            \"needReadable\": false,\n            \"emittedReadable\": false,\n            \"readableListening\": false,\n            \"resumeScheduled\": false,\n            \"errorEmitted\": false,\n            \"emitClose\": true,\n            \"autoDestroy\": false,\n            \"destroyed\": false,\n            \"errored\": null,\n            \"closed\": false,\n            \"closeEmitted\": false,\n            \"defaultEncoding\": \"utf8\",\n            \"awaitDrainWriters\": null,\n            \"multiAwaitDrain\": false,\n            \"readingMore\": true,\n            \"decoder\": null,\n            \"encoding\": null\n          },\n          \"_events\": {\n            \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n          },\n          \"_eventsCount\": 1,\n          \"socket\": \"[Circular ~.res.socket]\",\n          \"httpVersionMajor\": 1,\n          \"httpVersionMinor\": 1,\n          \"httpVersion\": \"1.1\",\n          \"complete\": false,\n          \"headers\": {\n            \"host\": \"localhost:3000\",\n            \"connection\": \"keep-alive\",\n            \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n            \"sec-fetch-site\": \"same-origin\",\n            \"sec-fetch-mode\": \"no-cors\",\n            \"sec-fetch-dest\": \"image\",\n            \"accept-encoding\": \"gzip, deflate, br\",\n            \"accept-language\": \"en-US,en;q=0.9\"\n          },\n          \"rawHeaders\": [\n            \"Host\",\n            \"localhost:3000\",\n            \"Connection\",\n            \"keep-alive\",\n            \"User-Agent\",\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"Accept\",\n            \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n            \"Sec-Fetch-Site\",\n            \"same-origin\",\n            \"Sec-Fetch-Mode\",\n            \"no-cors\",\n            \"Sec-Fetch-Dest\",\n            \"image\",\n            \"Accept-Encoding\",\n            \"gzip, deflate, br\",\n            \"Accept-Language\",\n            \"en-US,en;q=0.9\"\n          ],\n          \"trailers\": {},\n          \"rawTrailers\": [],\n          \"aborted\": false,\n          \"upgrade\": false,\n          \"url\": \"/favicon.ico\",\n          \"method\": \"GET\",\n          \"statusCode\": null,\n          \"statusMessage\": null,\n          \"client\": \"[Circular ~.res.socket]\",\n          \"_consuming\": false,\n          \"_dumped\": false,\n          \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n          \"baseUrl\": \"\",\n          \"originalUrl\": \"/favicon.ico\",\n          \"_parsedUrl\": {\n            \"protocol\": null,\n            \"slashes\": null,\n            \"auth\": null,\n            \"host\": null,\n            \"port\": null,\n            \"hostname\": null,\n            \"hash\": null,\n            \"search\": null,\n            \"query\": null,\n            \"pathname\": \"/favicon.ico\",\n            \"path\": \"/favicon.ico\",\n            \"href\": \"/favicon.ico\",\n            \"_raw\": \"/favicon.ico\"\n          },\n          \"params\": {},\n          \"query\": {},\n          \"res\": \"[Circular ~.res]\",\n          \"body\": {},\n          \"_startAt\": [\n            118644,\n            130451339\n          ],\n          \"_startTime\": \"2020-11-30T04:21:16.932Z\",\n          \"_remoteAddress\": \"::1\"\n        },\n        \"outgoing\": null,\n        \"maxHeaderPairs\": 2000,\n        \"_consumed\": true,\n        \"onIncoming\": function () { [native code] }\n      },\n      \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"_paused\": false,\n      \"_httpMessage\": \"[Circular ~.res]\",\n      \"_peername\": {\n        \"address\": \"::1\",\n        \"family\": \"IPv6\",\n        \"port\": 34038\n      },\n      \"timeout\": 0\n    },\n    \"_header\": null,\n    \"_keepAliveTimeout\": 5000,\n    \"_onPendingData\": function () { [native code] },\n    \"_sent100\": false,\n    \"_expect_continue\": false,\n    \"req\": {\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": null,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": false,\n        \"sync\": true,\n        \"needReadable\": false,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": true,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": true,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n      },\n      \"_eventsCount\": 1,\n      \"socket\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": false,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.socket]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 34038\n        },\n        \"timeout\": 0\n      },\n      \"httpVersionMajor\": 1,\n      \"httpVersionMinor\": 1,\n      \"httpVersion\": \"1.1\",\n      \"complete\": false,\n      \"headers\": {\n        \"host\": \"localhost:3000\",\n        \"connection\": \"keep-alive\",\n        \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n        \"sec-fetch-site\": \"same-origin\",\n        \"sec-fetch-mode\": \"no-cors\",\n        \"sec-fetch-dest\": \"image\",\n        \"accept-encoding\": \"gzip, deflate, br\",\n        \"accept-language\": \"en-US,en;q=0.9\"\n      },\n      \"rawHeaders\": [\n        \"Host\",\n        \"localhost:3000\",\n        \"Connection\",\n        \"keep-alive\",\n        \"User-Agent\",\n        \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"Accept\",\n        \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n        \"Sec-Fetch-Site\",\n        \"same-origin\",\n        \"Sec-Fetch-Mode\",\n        \"no-cors\",\n        \"Sec-Fetch-Dest\",\n        \"image\",\n        \"Accept-Encoding\",\n        \"gzip, deflate, br\",\n        \"Accept-Language\",\n        \"en-US,en;q=0.9\"\n      ],\n      \"trailers\": {},\n      \"rawTrailers\": [],\n      \"aborted\": false,\n      \"upgrade\": false,\n      \"url\": \"/favicon.ico\",\n      \"method\": \"GET\",\n      \"statusCode\": null,\n      \"statusMessage\": null,\n      \"client\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": false,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.client]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 34038\n        },\n        \"timeout\": 0\n      },\n      \"_consuming\": false,\n      \"_dumped\": false,\n      \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n      \"baseUrl\": \"\",\n      \"originalUrl\": \"/favicon.ico\",\n      \"_parsedUrl\": {\n        \"protocol\": null,\n        \"slashes\": null,\n        \"auth\": null,\n        \"host\": null,\n        \"port\": null,\n        \"hostname\": null,\n        \"hash\": null,\n        \"search\": null,\n        \"query\": null,\n        \"pathname\": \"/favicon.ico\",\n        \"path\": \"/favicon.ico\",\n        \"href\": \"/favicon.ico\",\n        \"_raw\": \"/favicon.ico\"\n      },\n      \"params\": {},\n      \"query\": {},\n      \"res\": \"[Circular ~.res]\",\n      \"body\": {},\n      \"_startAt\": [\n        118644,\n        130451339\n      ],\n      \"_startTime\": \"2020-11-30T04:21:16.932Z\",\n      \"_remoteAddress\": \"::1\"\n    },\n    \"locals\": {},\n    \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n    \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n    \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n    \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n    \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n    \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n  },\n  \"body\": {},\n  \"_startAt\": [\n    118644,\n    130451339\n  ],\n  \"_startTime\": \"2020-11-30T04:21:16.932Z\",\n  \"_remoteAddress\": \"::1\",\n  \"statusCode\" \u001b[31m[1]\u001b[0m: null\n}\n\u001b[31m\n[1] \"statusCode\" must be one of [400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511]\u001b[0m","level":"error","service":"monkey"}
{"message":"{\n  \"_readableState\": {\n    \"objectMode\": false,\n    \"highWaterMark\": 16384,\n    \"buffer\": {\n      \"head\": null,\n      \"tail\": null,\n      \"length\": 0\n    },\n    \"length\": 0,\n    \"pipes\": [],\n    \"flowing\": null,\n    \"ended\": false,\n    \"endEmitted\": false,\n    \"reading\": false,\n    \"sync\": true,\n    \"needReadable\": false,\n    \"emittedReadable\": false,\n    \"readableListening\": false,\n    \"resumeScheduled\": false,\n    \"errorEmitted\": false,\n    \"emitClose\": true,\n    \"autoDestroy\": false,\n    \"destroyed\": false,\n    \"errored\": null,\n    \"closed\": false,\n    \"closeEmitted\": false,\n    \"defaultEncoding\": \"utf8\",\n    \"awaitDrainWriters\": null,\n    \"multiAwaitDrain\": false,\n    \"readingMore\": true,\n    \"decoder\": null,\n    \"encoding\": null\n  },\n  \"_events\": {\n    \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n  },\n  \"_eventsCount\": 1,\n  \"socket\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": true,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.socket]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"cache-control\": \"max-age=0\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Cache-Control\",\n          \"max-age=0\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.socket]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.socket.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118762,\n          673943389\n        ],\n        \"_startTime\": \"2020-11-30T04:23:15.475Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.socket]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"cache-control\": \"max-age=0\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Cache-Control\",\n          \"max-age=0\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.socket._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118762,\n          673943389\n        ],\n        \"_startTime\": \"2020-11-30T04:23:15.475Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 34158\n    }\n  },\n  \"httpVersionMajor\": 1,\n  \"httpVersionMinor\": 1,\n  \"httpVersion\": \"1.1\",\n  \"complete\": false,\n  \"headers\": {\n    \"host\": \"localhost:3000\",\n    \"connection\": \"keep-alive\",\n    \"cache-control\": \"max-age=0\",\n    \"upgrade-insecure-requests\": \"1\",\n    \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n    \"sec-fetch-site\": \"none\",\n    \"sec-fetch-mode\": \"navigate\",\n    \"sec-fetch-user\": \"?1\",\n    \"sec-fetch-dest\": \"document\",\n    \"accept-encoding\": \"gzip, deflate, br\",\n    \"accept-language\": \"en-US,en;q=0.9\"\n  },\n  \"rawHeaders\": [\n    \"Host\",\n    \"localhost:3000\",\n    \"Connection\",\n    \"keep-alive\",\n    \"Cache-Control\",\n    \"max-age=0\",\n    \"Upgrade-Insecure-Requests\",\n    \"1\",\n    \"User-Agent\",\n    \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"Accept\",\n    \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n    \"Sec-Fetch-Site\",\n    \"none\",\n    \"Sec-Fetch-Mode\",\n    \"navigate\",\n    \"Sec-Fetch-User\",\n    \"?1\",\n    \"Sec-Fetch-Dest\",\n    \"document\",\n    \"Accept-Encoding\",\n    \"gzip, deflate, br\",\n    \"Accept-Language\",\n    \"en-US,en;q=0.9\"\n  ],\n  \"trailers\": {},\n  \"rawTrailers\": [],\n  \"aborted\": false,\n  \"upgrade\": false,\n  \"url\": \"/\",\n  \"method\": \"GET\",\n  \"statusMessage\": null,\n  \"client\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": true,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.client]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"cache-control\": \"max-age=0\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Cache-Control\",\n          \"max-age=0\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.client]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.client.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118762,\n          673943389\n        ],\n        \"_startTime\": \"2020-11-30T04:23:15.475Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.client]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"cache-control\": \"max-age=0\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Cache-Control\",\n          \"max-age=0\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.client._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118762,\n          673943389\n        ],\n        \"_startTime\": \"2020-11-30T04:23:15.475Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 34158\n    }\n  },\n  \"_consuming\": false,\n  \"_dumped\": false,\n  \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n  \"baseUrl\": \"\",\n  \"originalUrl\": \"/\",\n  \"_parsedUrl\": {\n    \"protocol\": null,\n    \"slashes\": null,\n    \"auth\": null,\n    \"host\": null,\n    \"port\": null,\n    \"hostname\": null,\n    \"hash\": null,\n    \"search\": null,\n    \"query\": null,\n    \"pathname\": \"/\",\n    \"path\": \"/\",\n    \"href\": \"/\",\n    \"_raw\": \"/\"\n  },\n  \"params\": {},\n  \"query\": {},\n  \"res\": {\n    \"_events\": {\n      \"finish\": [\n        function () { [native code] },\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n    },\n    \"_eventsCount\": 2,\n    \"outputData\": [],\n    \"outputSize\": 0,\n    \"writable\": true,\n    \"destroyed\": false,\n    \"_last\": false,\n    \"chunkedEncoding\": false,\n    \"shouldKeepAlive\": true,\n    \"_defaultKeepAlive\": true,\n    \"useChunkedEncodingByDefault\": true,\n    \"sendDate\": true,\n    \"_removedConnection\": false,\n    \"_removedContLen\": false,\n    \"_removedTE\": false,\n    \"_contentLength\": null,\n    \"_hasBody\": true,\n    \"_trailer\": \"\",\n    \"finished\": false,\n    \"_headerSent\": false,\n    \"socket\": {\n      \"connecting\": false,\n      \"_hadError\": false,\n      \"_parent\": null,\n      \"_host\": null,\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": true,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": true,\n        \"sync\": false,\n        \"needReadable\": true,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": false,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": [\n          function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n          function () { [native code] }\n        ],\n        \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n        \"data\": function () { [native code] },\n        \"error\": [\n          function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"close\": [\n          function () { [native code] },\n          function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"drain\": function () { [native code] },\n        \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n        \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n      },\n      \"_eventsCount\": 8,\n      \"_writableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"finalCalled\": false,\n        \"needDrain\": false,\n        \"ending\": false,\n        \"ended\": false,\n        \"finished\": false,\n        \"destroyed\": false,\n        \"decodeStrings\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"length\": 0,\n        \"writing\": false,\n        \"corked\": 0,\n        \"sync\": true,\n        \"bufferProcessing\": false,\n        \"onwrite\": function () { [native code] },\n        \"writecb\": null,\n        \"writelen\": 0,\n        \"afterWriteTickInfo\": null,\n        \"buffered\": [],\n        \"bufferedIndex\": 0,\n        \"allBuffers\": true,\n        \"allNoop\": true,\n        \"pendingcb\": 0,\n        \"prefinished\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false\n      },\n      \"allowHalfOpen\": true,\n      \"_sockname\": null,\n      \"_pendingData\": null,\n      \"_pendingEncoding\": \"\",\n      \"server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"_server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"parser\": {\n        \"0\": function () { [native code] },\n        \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n        \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n        \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n        \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n        \"5\": function () { [native code] },\n        \"6\": function () { [native code] },\n        \"_headers\": [],\n        \"_url\": \"\",\n        \"socket\": \"[Circular ~.res.socket]\",\n        \"incoming\": {\n          \"_readableState\": {\n            \"objectMode\": false,\n            \"highWaterMark\": 16384,\n            \"buffer\": {\n              \"head\": null,\n              \"tail\": null,\n              \"length\": 0\n            },\n            \"length\": 0,\n            \"pipes\": [],\n            \"flowing\": null,\n            \"ended\": false,\n            \"endEmitted\": false,\n            \"reading\": false,\n            \"sync\": true,\n            \"needReadable\": false,\n            \"emittedReadable\": false,\n            \"readableListening\": false,\n            \"resumeScheduled\": false,\n            \"errorEmitted\": false,\n            \"emitClose\": true,\n            \"autoDestroy\": false,\n            \"destroyed\": false,\n            \"errored\": null,\n            \"closed\": false,\n            \"closeEmitted\": false,\n            \"defaultEncoding\": \"utf8\",\n            \"awaitDrainWriters\": null,\n            \"multiAwaitDrain\": false,\n            \"readingMore\": true,\n            \"decoder\": null,\n            \"encoding\": null\n          },\n          \"_events\": {\n            \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n          },\n          \"_eventsCount\": 1,\n          \"socket\": \"[Circular ~.res.socket]\",\n          \"httpVersionMajor\": 1,\n          \"httpVersionMinor\": 1,\n          \"httpVersion\": \"1.1\",\n          \"complete\": false,\n          \"headers\": {\n            \"host\": \"localhost:3000\",\n            \"connection\": \"keep-alive\",\n            \"cache-control\": \"max-age=0\",\n            \"upgrade-insecure-requests\": \"1\",\n            \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n            \"sec-fetch-site\": \"none\",\n            \"sec-fetch-mode\": \"navigate\",\n            \"sec-fetch-user\": \"?1\",\n            \"sec-fetch-dest\": \"document\",\n            \"accept-encoding\": \"gzip, deflate, br\",\n            \"accept-language\": \"en-US,en;q=0.9\"\n          },\n          \"rawHeaders\": [\n            \"Host\",\n            \"localhost:3000\",\n            \"Connection\",\n            \"keep-alive\",\n            \"Cache-Control\",\n            \"max-age=0\",\n            \"Upgrade-Insecure-Requests\",\n            \"1\",\n            \"User-Agent\",\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"Accept\",\n            \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n            \"Sec-Fetch-Site\",\n            \"none\",\n            \"Sec-Fetch-Mode\",\n            \"navigate\",\n            \"Sec-Fetch-User\",\n            \"?1\",\n            \"Sec-Fetch-Dest\",\n            \"document\",\n            \"Accept-Encoding\",\n            \"gzip, deflate, br\",\n            \"Accept-Language\",\n            \"en-US,en;q=0.9\"\n          ],\n          \"trailers\": {},\n          \"rawTrailers\": [],\n          \"aborted\": false,\n          \"upgrade\": false,\n          \"url\": \"/\",\n          \"method\": \"GET\",\n          \"statusCode\": null,\n          \"statusMessage\": null,\n          \"client\": \"[Circular ~.res.socket]\",\n          \"_consuming\": false,\n          \"_dumped\": false,\n          \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n          \"baseUrl\": \"\",\n          \"originalUrl\": \"/\",\n          \"_parsedUrl\": {\n            \"protocol\": null,\n            \"slashes\": null,\n            \"auth\": null,\n            \"host\": null,\n            \"port\": null,\n            \"hostname\": null,\n            \"hash\": null,\n            \"search\": null,\n            \"query\": null,\n            \"pathname\": \"/\",\n            \"path\": \"/\",\n            \"href\": \"/\",\n            \"_raw\": \"/\"\n          },\n          \"params\": {},\n          \"query\": {},\n          \"res\": \"[Circular ~.res]\",\n          \"body\": {},\n          \"_startAt\": [\n            118762,\n            673943389\n          ],\n          \"_startTime\": \"2020-11-30T04:23:15.475Z\",\n          \"_remoteAddress\": \"::1\"\n        },\n        \"outgoing\": null,\n        \"maxHeaderPairs\": 2000,\n        \"_consumed\": true,\n        \"onIncoming\": function () { [native code] }\n      },\n      \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"_paused\": false,\n      \"_httpMessage\": \"[Circular ~.res]\",\n      \"_peername\": {\n        \"address\": \"::1\",\n        \"family\": \"IPv6\",\n        \"port\": 34158\n      }\n    },\n    \"_header\": null,\n    \"_keepAliveTimeout\": 5000,\n    \"_onPendingData\": function () { [native code] },\n    \"_sent100\": false,\n    \"_expect_continue\": false,\n    \"req\": {\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": null,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": false,\n        \"sync\": true,\n        \"needReadable\": false,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": true,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": true,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n      },\n      \"_eventsCount\": 1,\n      \"socket\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": true,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.socket]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 34158\n        }\n      },\n      \"httpVersionMajor\": 1,\n      \"httpVersionMinor\": 1,\n      \"httpVersion\": \"1.1\",\n      \"complete\": false,\n      \"headers\": {\n        \"host\": \"localhost:3000\",\n        \"connection\": \"keep-alive\",\n        \"cache-control\": \"max-age=0\",\n        \"upgrade-insecure-requests\": \"1\",\n        \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n        \"sec-fetch-site\": \"none\",\n        \"sec-fetch-mode\": \"navigate\",\n        \"sec-fetch-user\": \"?1\",\n        \"sec-fetch-dest\": \"document\",\n        \"accept-encoding\": \"gzip, deflate, br\",\n        \"accept-language\": \"en-US,en;q=0.9\"\n      },\n      \"rawHeaders\": [\n        \"Host\",\n        \"localhost:3000\",\n        \"Connection\",\n        \"keep-alive\",\n        \"Cache-Control\",\n        \"max-age=0\",\n        \"Upgrade-Insecure-Requests\",\n        \"1\",\n        \"User-Agent\",\n        \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"Accept\",\n        \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n        \"Sec-Fetch-Site\",\n        \"none\",\n        \"Sec-Fetch-Mode\",\n        \"navigate\",\n        \"Sec-Fetch-User\",\n        \"?1\",\n        \"Sec-Fetch-Dest\",\n        \"document\",\n        \"Accept-Encoding\",\n        \"gzip, deflate, br\",\n        \"Accept-Language\",\n        \"en-US,en;q=0.9\"\n      ],\n      \"trailers\": {},\n      \"rawTrailers\": [],\n      \"aborted\": false,\n      \"upgrade\": false,\n      \"url\": \"/\",\n      \"method\": \"GET\",\n      \"statusCode\": null,\n      \"statusMessage\": null,\n      \"client\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": true,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.client]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 34158\n        }\n      },\n      \"_consuming\": false,\n      \"_dumped\": false,\n      \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n      \"baseUrl\": \"\",\n      \"originalUrl\": \"/\",\n      \"_parsedUrl\": {\n        \"protocol\": null,\n        \"slashes\": null,\n        \"auth\": null,\n        \"host\": null,\n        \"port\": null,\n        \"hostname\": null,\n        \"hash\": null,\n        \"search\": null,\n        \"query\": null,\n        \"pathname\": \"/\",\n        \"path\": \"/\",\n        \"href\": \"/\",\n        \"_raw\": \"/\"\n      },\n      \"params\": {},\n      \"query\": {},\n      \"res\": \"[Circular ~.res]\",\n      \"body\": {},\n      \"_startAt\": [\n        118762,\n        673943389\n      ],\n      \"_startTime\": \"2020-11-30T04:23:15.475Z\",\n      \"_remoteAddress\": \"::1\"\n    },\n    \"locals\": {},\n    \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n    \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n    \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n    \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n    \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n    \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n  },\n  \"body\": {},\n  \"_startAt\": [\n    118762,\n    673943389\n  ],\n  \"_startTime\": \"2020-11-30T04:23:15.475Z\",\n  \"_remoteAddress\": \"::1\",\n  \"statusCode\" \u001b[31m[1]\u001b[0m: null\n}\n\u001b[31m\n[1] \"statusCode\" must be one of [400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511]\u001b[0m","level":"error","service":"monkey"}
{"message":"{\n  \"_readableState\": {\n    \"objectMode\": false,\n    \"highWaterMark\": 16384,\n    \"buffer\": {\n      \"head\": null,\n      \"tail\": null,\n      \"length\": 0\n    },\n    \"length\": 0,\n    \"pipes\": [],\n    \"flowing\": null,\n    \"ended\": false,\n    \"endEmitted\": false,\n    \"reading\": false,\n    \"sync\": true,\n    \"needReadable\": false,\n    \"emittedReadable\": false,\n    \"readableListening\": false,\n    \"resumeScheduled\": false,\n    \"errorEmitted\": false,\n    \"emitClose\": true,\n    \"autoDestroy\": false,\n    \"destroyed\": false,\n    \"errored\": null,\n    \"closed\": false,\n    \"closeEmitted\": false,\n    \"defaultEncoding\": \"utf8\",\n    \"awaitDrainWriters\": null,\n    \"multiAwaitDrain\": false,\n    \"readingMore\": true,\n    \"decoder\": null,\n    \"encoding\": null\n  },\n  \"_events\": {\n    \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n  },\n  \"_eventsCount\": 1,\n  \"socket\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": false,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.socket]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"pragma\": \"no-cache\",\n          \"cache-control\": \"no-cache\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Pragma\",\n          \"no-cache\",\n          \"Cache-Control\",\n          \"no-cache\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.socket]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.socket.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118762,\n          821381724\n        ],\n        \"_startTime\": \"2020-11-30T04:23:15.623Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.socket]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"pragma\": \"no-cache\",\n          \"cache-control\": \"no-cache\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Pragma\",\n          \"no-cache\",\n          \"Cache-Control\",\n          \"no-cache\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.socket._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118762,\n          821381724\n        ],\n        \"_startTime\": \"2020-11-30T04:23:15.623Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 34158\n    },\n    \"timeout\": 0\n  },\n  \"httpVersionMajor\": 1,\n  \"httpVersionMinor\": 1,\n  \"httpVersion\": \"1.1\",\n  \"complete\": false,\n  \"headers\": {\n    \"host\": \"localhost:3000\",\n    \"connection\": \"keep-alive\",\n    \"pragma\": \"no-cache\",\n    \"cache-control\": \"no-cache\",\n    \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n    \"sec-fetch-site\": \"same-origin\",\n    \"sec-fetch-mode\": \"no-cors\",\n    \"sec-fetch-dest\": \"image\",\n    \"accept-encoding\": \"gzip, deflate, br\",\n    \"accept-language\": \"en-US,en;q=0.9\"\n  },\n  \"rawHeaders\": [\n    \"Host\",\n    \"localhost:3000\",\n    \"Connection\",\n    \"keep-alive\",\n    \"Pragma\",\n    \"no-cache\",\n    \"Cache-Control\",\n    \"no-cache\",\n    \"User-Agent\",\n    \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"Accept\",\n    \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n    \"Sec-Fetch-Site\",\n    \"same-origin\",\n    \"Sec-Fetch-Mode\",\n    \"no-cors\",\n    \"Sec-Fetch-Dest\",\n    \"image\",\n    \"Accept-Encoding\",\n    \"gzip, deflate, br\",\n    \"Accept-Language\",\n    \"en-US,en;q=0.9\"\n  ],\n  \"trailers\": {},\n  \"rawTrailers\": [],\n  \"aborted\": false,\n  \"upgrade\": false,\n  \"url\": \"/favicon.ico\",\n  \"method\": \"GET\",\n  \"statusMessage\": null,\n  \"client\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": false,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.client]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"pragma\": \"no-cache\",\n          \"cache-control\": \"no-cache\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Pragma\",\n          \"no-cache\",\n          \"Cache-Control\",\n          \"no-cache\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.client]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.client.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118762,\n          821381724\n        ],\n        \"_startTime\": \"2020-11-30T04:23:15.623Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.client]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"pragma\": \"no-cache\",\n          \"cache-control\": \"no-cache\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Pragma\",\n          \"no-cache\",\n          \"Cache-Control\",\n          \"no-cache\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.client._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118762,\n          821381724\n        ],\n        \"_startTime\": \"2020-11-30T04:23:15.623Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 34158\n    },\n    \"timeout\": 0\n  },\n  \"_consuming\": false,\n  \"_dumped\": false,\n  \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n  \"baseUrl\": \"\",\n  \"originalUrl\": \"/favicon.ico\",\n  \"_parsedUrl\": {\n    \"protocol\": null,\n    \"slashes\": null,\n    \"auth\": null,\n    \"host\": null,\n    \"port\": null,\n    \"hostname\": null,\n    \"hash\": null,\n    \"search\": null,\n    \"query\": null,\n    \"pathname\": \"/favicon.ico\",\n    \"path\": \"/favicon.ico\",\n    \"href\": \"/favicon.ico\",\n    \"_raw\": \"/favicon.ico\"\n  },\n  \"params\": {},\n  \"query\": {},\n  \"res\": {\n    \"_events\": {\n      \"finish\": [\n        function () { [native code] },\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n    },\n    \"_eventsCount\": 2,\n    \"outputData\": [],\n    \"outputSize\": 0,\n    \"writable\": true,\n    \"destroyed\": false,\n    \"_last\": false,\n    \"chunkedEncoding\": false,\n    \"shouldKeepAlive\": true,\n    \"_defaultKeepAlive\": true,\n    \"useChunkedEncodingByDefault\": true,\n    \"sendDate\": true,\n    \"_removedConnection\": false,\n    \"_removedContLen\": false,\n    \"_removedTE\": false,\n    \"_contentLength\": null,\n    \"_hasBody\": true,\n    \"_trailer\": \"\",\n    \"finished\": false,\n    \"_headerSent\": false,\n    \"socket\": {\n      \"connecting\": false,\n      \"_hadError\": false,\n      \"_parent\": null,\n      \"_host\": null,\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": true,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": true,\n        \"sync\": false,\n        \"needReadable\": true,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": false,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": [\n          function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n          function () { [native code] }\n        ],\n        \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n        \"data\": function () { [native code] },\n        \"error\": [\n          function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"close\": [\n          function () { [native code] },\n          function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"drain\": function () { [native code] },\n        \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n        \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n      },\n      \"_eventsCount\": 8,\n      \"_writableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"finalCalled\": false,\n        \"needDrain\": false,\n        \"ending\": false,\n        \"ended\": false,\n        \"finished\": false,\n        \"destroyed\": false,\n        \"decodeStrings\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"length\": 0,\n        \"writing\": false,\n        \"corked\": 0,\n        \"sync\": false,\n        \"bufferProcessing\": false,\n        \"onwrite\": function () { [native code] },\n        \"writecb\": null,\n        \"writelen\": 0,\n        \"afterWriteTickInfo\": null,\n        \"buffered\": [],\n        \"bufferedIndex\": 0,\n        \"allBuffers\": true,\n        \"allNoop\": true,\n        \"pendingcb\": 0,\n        \"prefinished\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false\n      },\n      \"allowHalfOpen\": true,\n      \"_sockname\": null,\n      \"_pendingData\": null,\n      \"_pendingEncoding\": \"\",\n      \"server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"_server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"parser\": {\n        \"0\": function () { [native code] },\n        \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n        \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n        \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n        \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n        \"5\": function () { [native code] },\n        \"6\": function () { [native code] },\n        \"_headers\": [],\n        \"_url\": \"\",\n        \"socket\": \"[Circular ~.res.socket]\",\n        \"incoming\": {\n          \"_readableState\": {\n            \"objectMode\": false,\n            \"highWaterMark\": 16384,\n            \"buffer\": {\n              \"head\": null,\n              \"tail\": null,\n              \"length\": 0\n            },\n            \"length\": 0,\n            \"pipes\": [],\n            \"flowing\": null,\n            \"ended\": false,\n            \"endEmitted\": false,\n            \"reading\": false,\n            \"sync\": true,\n            \"needReadable\": false,\n            \"emittedReadable\": false,\n            \"readableListening\": false,\n            \"resumeScheduled\": false,\n            \"errorEmitted\": false,\n            \"emitClose\": true,\n            \"autoDestroy\": false,\n            \"destroyed\": false,\n            \"errored\": null,\n            \"closed\": false,\n            \"closeEmitted\": false,\n            \"defaultEncoding\": \"utf8\",\n            \"awaitDrainWriters\": null,\n            \"multiAwaitDrain\": false,\n            \"readingMore\": true,\n            \"decoder\": null,\n            \"encoding\": null\n          },\n          \"_events\": {\n            \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n          },\n          \"_eventsCount\": 1,\n          \"socket\": \"[Circular ~.res.socket]\",\n          \"httpVersionMajor\": 1,\n          \"httpVersionMinor\": 1,\n          \"httpVersion\": \"1.1\",\n          \"complete\": false,\n          \"headers\": {\n            \"host\": \"localhost:3000\",\n            \"connection\": \"keep-alive\",\n            \"pragma\": \"no-cache\",\n            \"cache-control\": \"no-cache\",\n            \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n            \"sec-fetch-site\": \"same-origin\",\n            \"sec-fetch-mode\": \"no-cors\",\n            \"sec-fetch-dest\": \"image\",\n            \"accept-encoding\": \"gzip, deflate, br\",\n            \"accept-language\": \"en-US,en;q=0.9\"\n          },\n          \"rawHeaders\": [\n            \"Host\",\n            \"localhost:3000\",\n            \"Connection\",\n            \"keep-alive\",\n            \"Pragma\",\n            \"no-cache\",\n            \"Cache-Control\",\n            \"no-cache\",\n            \"User-Agent\",\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"Accept\",\n            \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n            \"Sec-Fetch-Site\",\n            \"same-origin\",\n            \"Sec-Fetch-Mode\",\n            \"no-cors\",\n            \"Sec-Fetch-Dest\",\n            \"image\",\n            \"Accept-Encoding\",\n            \"gzip, deflate, br\",\n            \"Accept-Language\",\n            \"en-US,en;q=0.9\"\n          ],\n          \"trailers\": {},\n          \"rawTrailers\": [],\n          \"aborted\": false,\n          \"upgrade\": false,\n          \"url\": \"/favicon.ico\",\n          \"method\": \"GET\",\n          \"statusCode\": null,\n          \"statusMessage\": null,\n          \"client\": \"[Circular ~.res.socket]\",\n          \"_consuming\": false,\n          \"_dumped\": false,\n          \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n          \"baseUrl\": \"\",\n          \"originalUrl\": \"/favicon.ico\",\n          \"_parsedUrl\": {\n            \"protocol\": null,\n            \"slashes\": null,\n            \"auth\": null,\n            \"host\": null,\n            \"port\": null,\n            \"hostname\": null,\n            \"hash\": null,\n            \"search\": null,\n            \"query\": null,\n            \"pathname\": \"/favicon.ico\",\n            \"path\": \"/favicon.ico\",\n            \"href\": \"/favicon.ico\",\n            \"_raw\": \"/favicon.ico\"\n          },\n          \"params\": {},\n          \"query\": {},\n          \"res\": \"[Circular ~.res]\",\n          \"body\": {},\n          \"_startAt\": [\n            118762,\n            821381724\n          ],\n          \"_startTime\": \"2020-11-30T04:23:15.623Z\",\n          \"_remoteAddress\": \"::1\"\n        },\n        \"outgoing\": null,\n        \"maxHeaderPairs\": 2000,\n        \"_consumed\": true,\n        \"onIncoming\": function () { [native code] }\n      },\n      \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"_paused\": false,\n      \"_httpMessage\": \"[Circular ~.res]\",\n      \"_peername\": {\n        \"address\": \"::1\",\n        \"family\": \"IPv6\",\n        \"port\": 34158\n      },\n      \"timeout\": 0\n    },\n    \"_header\": null,\n    \"_keepAliveTimeout\": 5000,\n    \"_onPendingData\": function () { [native code] },\n    \"_sent100\": false,\n    \"_expect_continue\": false,\n    \"req\": {\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": null,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": false,\n        \"sync\": true,\n        \"needReadable\": false,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": true,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": true,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n      },\n      \"_eventsCount\": 1,\n      \"socket\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": false,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.socket]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 34158\n        },\n        \"timeout\": 0\n      },\n      \"httpVersionMajor\": 1,\n      \"httpVersionMinor\": 1,\n      \"httpVersion\": \"1.1\",\n      \"complete\": false,\n      \"headers\": {\n        \"host\": \"localhost:3000\",\n        \"connection\": \"keep-alive\",\n        \"pragma\": \"no-cache\",\n        \"cache-control\": \"no-cache\",\n        \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n        \"sec-fetch-site\": \"same-origin\",\n        \"sec-fetch-mode\": \"no-cors\",\n        \"sec-fetch-dest\": \"image\",\n        \"accept-encoding\": \"gzip, deflate, br\",\n        \"accept-language\": \"en-US,en;q=0.9\"\n      },\n      \"rawHeaders\": [\n        \"Host\",\n        \"localhost:3000\",\n        \"Connection\",\n        \"keep-alive\",\n        \"Pragma\",\n        \"no-cache\",\n        \"Cache-Control\",\n        \"no-cache\",\n        \"User-Agent\",\n        \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"Accept\",\n        \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n        \"Sec-Fetch-Site\",\n        \"same-origin\",\n        \"Sec-Fetch-Mode\",\n        \"no-cors\",\n        \"Sec-Fetch-Dest\",\n        \"image\",\n        \"Accept-Encoding\",\n        \"gzip, deflate, br\",\n        \"Accept-Language\",\n        \"en-US,en;q=0.9\"\n      ],\n      \"trailers\": {},\n      \"rawTrailers\": [],\n      \"aborted\": false,\n      \"upgrade\": false,\n      \"url\": \"/favicon.ico\",\n      \"method\": \"GET\",\n      \"statusCode\": null,\n      \"statusMessage\": null,\n      \"client\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": false,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.client]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 34158\n        },\n        \"timeout\": 0\n      },\n      \"_consuming\": false,\n      \"_dumped\": false,\n      \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n      \"baseUrl\": \"\",\n      \"originalUrl\": \"/favicon.ico\",\n      \"_parsedUrl\": {\n        \"protocol\": null,\n        \"slashes\": null,\n        \"auth\": null,\n        \"host\": null,\n        \"port\": null,\n        \"hostname\": null,\n        \"hash\": null,\n        \"search\": null,\n        \"query\": null,\n        \"pathname\": \"/favicon.ico\",\n        \"path\": \"/favicon.ico\",\n        \"href\": \"/favicon.ico\",\n        \"_raw\": \"/favicon.ico\"\n      },\n      \"params\": {},\n      \"query\": {},\n      \"res\": \"[Circular ~.res]\",\n      \"body\": {},\n      \"_startAt\": [\n        118762,\n        821381724\n      ],\n      \"_startTime\": \"2020-11-30T04:23:15.623Z\",\n      \"_remoteAddress\": \"::1\"\n    },\n    \"locals\": {},\n    \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n    \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n    \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n    \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n    \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n    \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n  },\n  \"body\": {},\n  \"_startAt\": [\n    118762,\n    821381724\n  ],\n  \"_startTime\": \"2020-11-30T04:23:15.623Z\",\n  \"_remoteAddress\": \"::1\",\n  \"statusCode\" \u001b[31m[1]\u001b[0m: null\n}\n\u001b[31m\n[1] \"statusCode\" must be one of [400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511]\u001b[0m","level":"error","service":"monkey"}
{"message":"{\n  \"_readableState\": {\n    \"objectMode\": false,\n    \"highWaterMark\": 16384,\n    \"buffer\": {\n      \"head\": null,\n      \"tail\": null,\n      \"length\": 0\n    },\n    \"length\": 0,\n    \"pipes\": [],\n    \"flowing\": null,\n    \"ended\": false,\n    \"endEmitted\": false,\n    \"reading\": false,\n    \"sync\": true,\n    \"needReadable\": false,\n    \"emittedReadable\": false,\n    \"readableListening\": false,\n    \"resumeScheduled\": false,\n    \"errorEmitted\": false,\n    \"emitClose\": true,\n    \"autoDestroy\": false,\n    \"destroyed\": false,\n    \"errored\": null,\n    \"closed\": false,\n    \"closeEmitted\": false,\n    \"defaultEncoding\": \"utf8\",\n    \"awaitDrainWriters\": null,\n    \"multiAwaitDrain\": false,\n    \"readingMore\": true,\n    \"decoder\": null,\n    \"encoding\": null\n  },\n  \"_events\": {\n    \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n  },\n  \"_eventsCount\": 1,\n  \"socket\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": true,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.socket]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"cache-control\": \"max-age=0\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Cache-Control\",\n          \"max-age=0\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.socket]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.socket.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118779,\n          887591967\n        ],\n        \"_startTime\": \"2020-11-30T04:23:32.689Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.socket]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"cache-control\": \"max-age=0\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Cache-Control\",\n          \"max-age=0\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.socket._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118779,\n          887591967\n        ],\n        \"_startTime\": \"2020-11-30T04:23:32.689Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 34164\n    }\n  },\n  \"httpVersionMajor\": 1,\n  \"httpVersionMinor\": 1,\n  \"httpVersion\": \"1.1\",\n  \"complete\": false,\n  \"headers\": {\n    \"host\": \"localhost:3000\",\n    \"connection\": \"keep-alive\",\n    \"cache-control\": \"max-age=0\",\n    \"upgrade-insecure-requests\": \"1\",\n    \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n    \"sec-fetch-site\": \"none\",\n    \"sec-fetch-mode\": \"navigate\",\n    \"sec-fetch-user\": \"?1\",\n    \"sec-fetch-dest\": \"document\",\n    \"accept-encoding\": \"gzip, deflate, br\",\n    \"accept-language\": \"en-US,en;q=0.9\"\n  },\n  \"rawHeaders\": [\n    \"Host\",\n    \"localhost:3000\",\n    \"Connection\",\n    \"keep-alive\",\n    \"Cache-Control\",\n    \"max-age=0\",\n    \"Upgrade-Insecure-Requests\",\n    \"1\",\n    \"User-Agent\",\n    \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"Accept\",\n    \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n    \"Sec-Fetch-Site\",\n    \"none\",\n    \"Sec-Fetch-Mode\",\n    \"navigate\",\n    \"Sec-Fetch-User\",\n    \"?1\",\n    \"Sec-Fetch-Dest\",\n    \"document\",\n    \"Accept-Encoding\",\n    \"gzip, deflate, br\",\n    \"Accept-Language\",\n    \"en-US,en;q=0.9\"\n  ],\n  \"trailers\": {},\n  \"rawTrailers\": [],\n  \"aborted\": false,\n  \"upgrade\": false,\n  \"url\": \"/\",\n  \"method\": \"GET\",\n  \"statusMessage\": null,\n  \"client\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": true,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.client]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"cache-control\": \"max-age=0\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Cache-Control\",\n          \"max-age=0\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.client]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.client.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118779,\n          887591967\n        ],\n        \"_startTime\": \"2020-11-30T04:23:32.689Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.client]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"cache-control\": \"max-age=0\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Cache-Control\",\n          \"max-age=0\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.client._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118779,\n          887591967\n        ],\n        \"_startTime\": \"2020-11-30T04:23:32.689Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 34164\n    }\n  },\n  \"_consuming\": false,\n  \"_dumped\": false,\n  \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n  \"baseUrl\": \"\",\n  \"originalUrl\": \"/\",\n  \"_parsedUrl\": {\n    \"protocol\": null,\n    \"slashes\": null,\n    \"auth\": null,\n    \"host\": null,\n    \"port\": null,\n    \"hostname\": null,\n    \"hash\": null,\n    \"search\": null,\n    \"query\": null,\n    \"pathname\": \"/\",\n    \"path\": \"/\",\n    \"href\": \"/\",\n    \"_raw\": \"/\"\n  },\n  \"params\": {},\n  \"query\": {},\n  \"res\": {\n    \"_events\": {\n      \"finish\": [\n        function () { [native code] },\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n    },\n    \"_eventsCount\": 2,\n    \"outputData\": [],\n    \"outputSize\": 0,\n    \"writable\": true,\n    \"destroyed\": false,\n    \"_last\": false,\n    \"chunkedEncoding\": false,\n    \"shouldKeepAlive\": true,\n    \"_defaultKeepAlive\": true,\n    \"useChunkedEncodingByDefault\": true,\n    \"sendDate\": true,\n    \"_removedConnection\": false,\n    \"_removedContLen\": false,\n    \"_removedTE\": false,\n    \"_contentLength\": null,\n    \"_hasBody\": true,\n    \"_trailer\": \"\",\n    \"finished\": false,\n    \"_headerSent\": false,\n    \"socket\": {\n      \"connecting\": false,\n      \"_hadError\": false,\n      \"_parent\": null,\n      \"_host\": null,\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": true,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": true,\n        \"sync\": false,\n        \"needReadable\": true,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": false,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": [\n          function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n          function () { [native code] }\n        ],\n        \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n        \"data\": function () { [native code] },\n        \"error\": [\n          function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"close\": [\n          function () { [native code] },\n          function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"drain\": function () { [native code] },\n        \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n        \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n      },\n      \"_eventsCount\": 8,\n      \"_writableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"finalCalled\": false,\n        \"needDrain\": false,\n        \"ending\": false,\n        \"ended\": false,\n        \"finished\": false,\n        \"destroyed\": false,\n        \"decodeStrings\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"length\": 0,\n        \"writing\": false,\n        \"corked\": 0,\n        \"sync\": true,\n        \"bufferProcessing\": false,\n        \"onwrite\": function () { [native code] },\n        \"writecb\": null,\n        \"writelen\": 0,\n        \"afterWriteTickInfo\": null,\n        \"buffered\": [],\n        \"bufferedIndex\": 0,\n        \"allBuffers\": true,\n        \"allNoop\": true,\n        \"pendingcb\": 0,\n        \"prefinished\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false\n      },\n      \"allowHalfOpen\": true,\n      \"_sockname\": null,\n      \"_pendingData\": null,\n      \"_pendingEncoding\": \"\",\n      \"server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"_server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"parser\": {\n        \"0\": function () { [native code] },\n        \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n        \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n        \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n        \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n        \"5\": function () { [native code] },\n        \"6\": function () { [native code] },\n        \"_headers\": [],\n        \"_url\": \"\",\n        \"socket\": \"[Circular ~.res.socket]\",\n        \"incoming\": {\n          \"_readableState\": {\n            \"objectMode\": false,\n            \"highWaterMark\": 16384,\n            \"buffer\": {\n              \"head\": null,\n              \"tail\": null,\n              \"length\": 0\n            },\n            \"length\": 0,\n            \"pipes\": [],\n            \"flowing\": null,\n            \"ended\": false,\n            \"endEmitted\": false,\n            \"reading\": false,\n            \"sync\": true,\n            \"needReadable\": false,\n            \"emittedReadable\": false,\n            \"readableListening\": false,\n            \"resumeScheduled\": false,\n            \"errorEmitted\": false,\n            \"emitClose\": true,\n            \"autoDestroy\": false,\n            \"destroyed\": false,\n            \"errored\": null,\n            \"closed\": false,\n            \"closeEmitted\": false,\n            \"defaultEncoding\": \"utf8\",\n            \"awaitDrainWriters\": null,\n            \"multiAwaitDrain\": false,\n            \"readingMore\": true,\n            \"decoder\": null,\n            \"encoding\": null\n          },\n          \"_events\": {\n            \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n          },\n          \"_eventsCount\": 1,\n          \"socket\": \"[Circular ~.res.socket]\",\n          \"httpVersionMajor\": 1,\n          \"httpVersionMinor\": 1,\n          \"httpVersion\": \"1.1\",\n          \"complete\": false,\n          \"headers\": {\n            \"host\": \"localhost:3000\",\n            \"connection\": \"keep-alive\",\n            \"cache-control\": \"max-age=0\",\n            \"upgrade-insecure-requests\": \"1\",\n            \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n            \"sec-fetch-site\": \"none\",\n            \"sec-fetch-mode\": \"navigate\",\n            \"sec-fetch-user\": \"?1\",\n            \"sec-fetch-dest\": \"document\",\n            \"accept-encoding\": \"gzip, deflate, br\",\n            \"accept-language\": \"en-US,en;q=0.9\"\n          },\n          \"rawHeaders\": [\n            \"Host\",\n            \"localhost:3000\",\n            \"Connection\",\n            \"keep-alive\",\n            \"Cache-Control\",\n            \"max-age=0\",\n            \"Upgrade-Insecure-Requests\",\n            \"1\",\n            \"User-Agent\",\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"Accept\",\n            \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n            \"Sec-Fetch-Site\",\n            \"none\",\n            \"Sec-Fetch-Mode\",\n            \"navigate\",\n            \"Sec-Fetch-User\",\n            \"?1\",\n            \"Sec-Fetch-Dest\",\n            \"document\",\n            \"Accept-Encoding\",\n            \"gzip, deflate, br\",\n            \"Accept-Language\",\n            \"en-US,en;q=0.9\"\n          ],\n          \"trailers\": {},\n          \"rawTrailers\": [],\n          \"aborted\": false,\n          \"upgrade\": false,\n          \"url\": \"/\",\n          \"method\": \"GET\",\n          \"statusCode\": null,\n          \"statusMessage\": null,\n          \"client\": \"[Circular ~.res.socket]\",\n          \"_consuming\": false,\n          \"_dumped\": false,\n          \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n          \"baseUrl\": \"\",\n          \"originalUrl\": \"/\",\n          \"_parsedUrl\": {\n            \"protocol\": null,\n            \"slashes\": null,\n            \"auth\": null,\n            \"host\": null,\n            \"port\": null,\n            \"hostname\": null,\n            \"hash\": null,\n            \"search\": null,\n            \"query\": null,\n            \"pathname\": \"/\",\n            \"path\": \"/\",\n            \"href\": \"/\",\n            \"_raw\": \"/\"\n          },\n          \"params\": {},\n          \"query\": {},\n          \"res\": \"[Circular ~.res]\",\n          \"body\": {},\n          \"_startAt\": [\n            118779,\n            887591967\n          ],\n          \"_startTime\": \"2020-11-30T04:23:32.689Z\",\n          \"_remoteAddress\": \"::1\"\n        },\n        \"outgoing\": null,\n        \"maxHeaderPairs\": 2000,\n        \"_consumed\": true,\n        \"onIncoming\": function () { [native code] }\n      },\n      \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"_paused\": false,\n      \"_httpMessage\": \"[Circular ~.res]\",\n      \"_peername\": {\n        \"address\": \"::1\",\n        \"family\": \"IPv6\",\n        \"port\": 34164\n      }\n    },\n    \"_header\": null,\n    \"_keepAliveTimeout\": 5000,\n    \"_onPendingData\": function () { [native code] },\n    \"_sent100\": false,\n    \"_expect_continue\": false,\n    \"req\": {\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": null,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": false,\n        \"sync\": true,\n        \"needReadable\": false,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": true,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": true,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n      },\n      \"_eventsCount\": 1,\n      \"socket\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": true,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.socket]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 34164\n        }\n      },\n      \"httpVersionMajor\": 1,\n      \"httpVersionMinor\": 1,\n      \"httpVersion\": \"1.1\",\n      \"complete\": false,\n      \"headers\": {\n        \"host\": \"localhost:3000\",\n        \"connection\": \"keep-alive\",\n        \"cache-control\": \"max-age=0\",\n        \"upgrade-insecure-requests\": \"1\",\n        \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n        \"sec-fetch-site\": \"none\",\n        \"sec-fetch-mode\": \"navigate\",\n        \"sec-fetch-user\": \"?1\",\n        \"sec-fetch-dest\": \"document\",\n        \"accept-encoding\": \"gzip, deflate, br\",\n        \"accept-language\": \"en-US,en;q=0.9\"\n      },\n      \"rawHeaders\": [\n        \"Host\",\n        \"localhost:3000\",\n        \"Connection\",\n        \"keep-alive\",\n        \"Cache-Control\",\n        \"max-age=0\",\n        \"Upgrade-Insecure-Requests\",\n        \"1\",\n        \"User-Agent\",\n        \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"Accept\",\n        \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n        \"Sec-Fetch-Site\",\n        \"none\",\n        \"Sec-Fetch-Mode\",\n        \"navigate\",\n        \"Sec-Fetch-User\",\n        \"?1\",\n        \"Sec-Fetch-Dest\",\n        \"document\",\n        \"Accept-Encoding\",\n        \"gzip, deflate, br\",\n        \"Accept-Language\",\n        \"en-US,en;q=0.9\"\n      ],\n      \"trailers\": {},\n      \"rawTrailers\": [],\n      \"aborted\": false,\n      \"upgrade\": false,\n      \"url\": \"/\",\n      \"method\": \"GET\",\n      \"statusCode\": null,\n      \"statusMessage\": null,\n      \"client\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": true,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.client]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 34164\n        }\n      },\n      \"_consuming\": false,\n      \"_dumped\": false,\n      \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n      \"baseUrl\": \"\",\n      \"originalUrl\": \"/\",\n      \"_parsedUrl\": {\n        \"protocol\": null,\n        \"slashes\": null,\n        \"auth\": null,\n        \"host\": null,\n        \"port\": null,\n        \"hostname\": null,\n        \"hash\": null,\n        \"search\": null,\n        \"query\": null,\n        \"pathname\": \"/\",\n        \"path\": \"/\",\n        \"href\": \"/\",\n        \"_raw\": \"/\"\n      },\n      \"params\": {},\n      \"query\": {},\n      \"res\": \"[Circular ~.res]\",\n      \"body\": {},\n      \"_startAt\": [\n        118779,\n        887591967\n      ],\n      \"_startTime\": \"2020-11-30T04:23:32.689Z\",\n      \"_remoteAddress\": \"::1\"\n    },\n    \"locals\": {},\n    \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n    \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n    \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n    \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n    \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n    \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n  },\n  \"body\": {},\n  \"_startAt\": [\n    118779,\n    887591967\n  ],\n  \"_startTime\": \"2020-11-30T04:23:32.689Z\",\n  \"_remoteAddress\": \"::1\",\n  \"statusCode\" \u001b[31m[1]\u001b[0m: null\n}\n\u001b[31m\n[1] \"statusCode\" must be one of [400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511]\u001b[0m","level":"error","service":"monkey"}
{"message":"{\n  \"_readableState\": {\n    \"objectMode\": false,\n    \"highWaterMark\": 16384,\n    \"buffer\": {\n      \"head\": null,\n      \"tail\": null,\n      \"length\": 0\n    },\n    \"length\": 0,\n    \"pipes\": [],\n    \"flowing\": null,\n    \"ended\": false,\n    \"endEmitted\": false,\n    \"reading\": false,\n    \"sync\": true,\n    \"needReadable\": false,\n    \"emittedReadable\": false,\n    \"readableListening\": false,\n    \"resumeScheduled\": false,\n    \"errorEmitted\": false,\n    \"emitClose\": true,\n    \"autoDestroy\": false,\n    \"destroyed\": false,\n    \"errored\": null,\n    \"closed\": false,\n    \"closeEmitted\": false,\n    \"defaultEncoding\": \"utf8\",\n    \"awaitDrainWriters\": null,\n    \"multiAwaitDrain\": false,\n    \"readingMore\": true,\n    \"decoder\": null,\n    \"encoding\": null\n  },\n  \"_events\": {\n    \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n  },\n  \"_eventsCount\": 1,\n  \"socket\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": false,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.socket]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"pragma\": \"no-cache\",\n          \"cache-control\": \"no-cache\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Pragma\",\n          \"no-cache\",\n          \"Cache-Control\",\n          \"no-cache\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.socket]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.socket.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118780,\n          37073485\n        ],\n        \"_startTime\": \"2020-11-30T04:23:32.838Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.socket]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"pragma\": \"no-cache\",\n          \"cache-control\": \"no-cache\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Pragma\",\n          \"no-cache\",\n          \"Cache-Control\",\n          \"no-cache\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.socket._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118780,\n          37073485\n        ],\n        \"_startTime\": \"2020-11-30T04:23:32.838Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 34164\n    },\n    \"timeout\": 0\n  },\n  \"httpVersionMajor\": 1,\n  \"httpVersionMinor\": 1,\n  \"httpVersion\": \"1.1\",\n  \"complete\": false,\n  \"headers\": {\n    \"host\": \"localhost:3000\",\n    \"connection\": \"keep-alive\",\n    \"pragma\": \"no-cache\",\n    \"cache-control\": \"no-cache\",\n    \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n    \"sec-fetch-site\": \"same-origin\",\n    \"sec-fetch-mode\": \"no-cors\",\n    \"sec-fetch-dest\": \"image\",\n    \"accept-encoding\": \"gzip, deflate, br\",\n    \"accept-language\": \"en-US,en;q=0.9\"\n  },\n  \"rawHeaders\": [\n    \"Host\",\n    \"localhost:3000\",\n    \"Connection\",\n    \"keep-alive\",\n    \"Pragma\",\n    \"no-cache\",\n    \"Cache-Control\",\n    \"no-cache\",\n    \"User-Agent\",\n    \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"Accept\",\n    \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n    \"Sec-Fetch-Site\",\n    \"same-origin\",\n    \"Sec-Fetch-Mode\",\n    \"no-cors\",\n    \"Sec-Fetch-Dest\",\n    \"image\",\n    \"Accept-Encoding\",\n    \"gzip, deflate, br\",\n    \"Accept-Language\",\n    \"en-US,en;q=0.9\"\n  ],\n  \"trailers\": {},\n  \"rawTrailers\": [],\n  \"aborted\": false,\n  \"upgrade\": false,\n  \"url\": \"/favicon.ico\",\n  \"method\": \"GET\",\n  \"statusMessage\": null,\n  \"client\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": false,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.client]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"pragma\": \"no-cache\",\n          \"cache-control\": \"no-cache\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Pragma\",\n          \"no-cache\",\n          \"Cache-Control\",\n          \"no-cache\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.client]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.client.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118780,\n          37073485\n        ],\n        \"_startTime\": \"2020-11-30T04:23:32.838Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.client]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"pragma\": \"no-cache\",\n          \"cache-control\": \"no-cache\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Pragma\",\n          \"no-cache\",\n          \"Cache-Control\",\n          \"no-cache\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.client._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118780,\n          37073485\n        ],\n        \"_startTime\": \"2020-11-30T04:23:32.838Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 34164\n    },\n    \"timeout\": 0\n  },\n  \"_consuming\": false,\n  \"_dumped\": false,\n  \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n  \"baseUrl\": \"\",\n  \"originalUrl\": \"/favicon.ico\",\n  \"_parsedUrl\": {\n    \"protocol\": null,\n    \"slashes\": null,\n    \"auth\": null,\n    \"host\": null,\n    \"port\": null,\n    \"hostname\": null,\n    \"hash\": null,\n    \"search\": null,\n    \"query\": null,\n    \"pathname\": \"/favicon.ico\",\n    \"path\": \"/favicon.ico\",\n    \"href\": \"/favicon.ico\",\n    \"_raw\": \"/favicon.ico\"\n  },\n  \"params\": {},\n  \"query\": {},\n  \"res\": {\n    \"_events\": {\n      \"finish\": [\n        function () { [native code] },\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n    },\n    \"_eventsCount\": 2,\n    \"outputData\": [],\n    \"outputSize\": 0,\n    \"writable\": true,\n    \"destroyed\": false,\n    \"_last\": false,\n    \"chunkedEncoding\": false,\n    \"shouldKeepAlive\": true,\n    \"_defaultKeepAlive\": true,\n    \"useChunkedEncodingByDefault\": true,\n    \"sendDate\": true,\n    \"_removedConnection\": false,\n    \"_removedContLen\": false,\n    \"_removedTE\": false,\n    \"_contentLength\": null,\n    \"_hasBody\": true,\n    \"_trailer\": \"\",\n    \"finished\": false,\n    \"_headerSent\": false,\n    \"socket\": {\n      \"connecting\": false,\n      \"_hadError\": false,\n      \"_parent\": null,\n      \"_host\": null,\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": true,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": true,\n        \"sync\": false,\n        \"needReadable\": true,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": false,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": [\n          function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n          function () { [native code] }\n        ],\n        \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n        \"data\": function () { [native code] },\n        \"error\": [\n          function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"close\": [\n          function () { [native code] },\n          function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"drain\": function () { [native code] },\n        \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n        \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n      },\n      \"_eventsCount\": 8,\n      \"_writableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"finalCalled\": false,\n        \"needDrain\": false,\n        \"ending\": false,\n        \"ended\": false,\n        \"finished\": false,\n        \"destroyed\": false,\n        \"decodeStrings\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"length\": 0,\n        \"writing\": false,\n        \"corked\": 0,\n        \"sync\": false,\n        \"bufferProcessing\": false,\n        \"onwrite\": function () { [native code] },\n        \"writecb\": null,\n        \"writelen\": 0,\n        \"afterWriteTickInfo\": null,\n        \"buffered\": [],\n        \"bufferedIndex\": 0,\n        \"allBuffers\": true,\n        \"allNoop\": true,\n        \"pendingcb\": 0,\n        \"prefinished\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false\n      },\n      \"allowHalfOpen\": true,\n      \"_sockname\": null,\n      \"_pendingData\": null,\n      \"_pendingEncoding\": \"\",\n      \"server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"_server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"parser\": {\n        \"0\": function () { [native code] },\n        \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n        \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n        \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n        \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n        \"5\": function () { [native code] },\n        \"6\": function () { [native code] },\n        \"_headers\": [],\n        \"_url\": \"\",\n        \"socket\": \"[Circular ~.res.socket]\",\n        \"incoming\": {\n          \"_readableState\": {\n            \"objectMode\": false,\n            \"highWaterMark\": 16384,\n            \"buffer\": {\n              \"head\": null,\n              \"tail\": null,\n              \"length\": 0\n            },\n            \"length\": 0,\n            \"pipes\": [],\n            \"flowing\": null,\n            \"ended\": false,\n            \"endEmitted\": false,\n            \"reading\": false,\n            \"sync\": true,\n            \"needReadable\": false,\n            \"emittedReadable\": false,\n            \"readableListening\": false,\n            \"resumeScheduled\": false,\n            \"errorEmitted\": false,\n            \"emitClose\": true,\n            \"autoDestroy\": false,\n            \"destroyed\": false,\n            \"errored\": null,\n            \"closed\": false,\n            \"closeEmitted\": false,\n            \"defaultEncoding\": \"utf8\",\n            \"awaitDrainWriters\": null,\n            \"multiAwaitDrain\": false,\n            \"readingMore\": true,\n            \"decoder\": null,\n            \"encoding\": null\n          },\n          \"_events\": {\n            \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n          },\n          \"_eventsCount\": 1,\n          \"socket\": \"[Circular ~.res.socket]\",\n          \"httpVersionMajor\": 1,\n          \"httpVersionMinor\": 1,\n          \"httpVersion\": \"1.1\",\n          \"complete\": false,\n          \"headers\": {\n            \"host\": \"localhost:3000\",\n            \"connection\": \"keep-alive\",\n            \"pragma\": \"no-cache\",\n            \"cache-control\": \"no-cache\",\n            \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n            \"sec-fetch-site\": \"same-origin\",\n            \"sec-fetch-mode\": \"no-cors\",\n            \"sec-fetch-dest\": \"image\",\n            \"accept-encoding\": \"gzip, deflate, br\",\n            \"accept-language\": \"en-US,en;q=0.9\"\n          },\n          \"rawHeaders\": [\n            \"Host\",\n            \"localhost:3000\",\n            \"Connection\",\n            \"keep-alive\",\n            \"Pragma\",\n            \"no-cache\",\n            \"Cache-Control\",\n            \"no-cache\",\n            \"User-Agent\",\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"Accept\",\n            \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n            \"Sec-Fetch-Site\",\n            \"same-origin\",\n            \"Sec-Fetch-Mode\",\n            \"no-cors\",\n            \"Sec-Fetch-Dest\",\n            \"image\",\n            \"Accept-Encoding\",\n            \"gzip, deflate, br\",\n            \"Accept-Language\",\n            \"en-US,en;q=0.9\"\n          ],\n          \"trailers\": {},\n          \"rawTrailers\": [],\n          \"aborted\": false,\n          \"upgrade\": false,\n          \"url\": \"/favicon.ico\",\n          \"method\": \"GET\",\n          \"statusCode\": null,\n          \"statusMessage\": null,\n          \"client\": \"[Circular ~.res.socket]\",\n          \"_consuming\": false,\n          \"_dumped\": false,\n          \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n          \"baseUrl\": \"\",\n          \"originalUrl\": \"/favicon.ico\",\n          \"_parsedUrl\": {\n            \"protocol\": null,\n            \"slashes\": null,\n            \"auth\": null,\n            \"host\": null,\n            \"port\": null,\n            \"hostname\": null,\n            \"hash\": null,\n            \"search\": null,\n            \"query\": null,\n            \"pathname\": \"/favicon.ico\",\n            \"path\": \"/favicon.ico\",\n            \"href\": \"/favicon.ico\",\n            \"_raw\": \"/favicon.ico\"\n          },\n          \"params\": {},\n          \"query\": {},\n          \"res\": \"[Circular ~.res]\",\n          \"body\": {},\n          \"_startAt\": [\n            118780,\n            37073485\n          ],\n          \"_startTime\": \"2020-11-30T04:23:32.838Z\",\n          \"_remoteAddress\": \"::1\"\n        },\n        \"outgoing\": null,\n        \"maxHeaderPairs\": 2000,\n        \"_consumed\": true,\n        \"onIncoming\": function () { [native code] }\n      },\n      \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"_paused\": false,\n      \"_httpMessage\": \"[Circular ~.res]\",\n      \"_peername\": {\n        \"address\": \"::1\",\n        \"family\": \"IPv6\",\n        \"port\": 34164\n      },\n      \"timeout\": 0\n    },\n    \"_header\": null,\n    \"_keepAliveTimeout\": 5000,\n    \"_onPendingData\": function () { [native code] },\n    \"_sent100\": false,\n    \"_expect_continue\": false,\n    \"req\": {\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": null,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": false,\n        \"sync\": true,\n        \"needReadable\": false,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": true,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": true,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n      },\n      \"_eventsCount\": 1,\n      \"socket\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": false,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.socket]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 34164\n        },\n        \"timeout\": 0\n      },\n      \"httpVersionMajor\": 1,\n      \"httpVersionMinor\": 1,\n      \"httpVersion\": \"1.1\",\n      \"complete\": false,\n      \"headers\": {\n        \"host\": \"localhost:3000\",\n        \"connection\": \"keep-alive\",\n        \"pragma\": \"no-cache\",\n        \"cache-control\": \"no-cache\",\n        \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n        \"sec-fetch-site\": \"same-origin\",\n        \"sec-fetch-mode\": \"no-cors\",\n        \"sec-fetch-dest\": \"image\",\n        \"accept-encoding\": \"gzip, deflate, br\",\n        \"accept-language\": \"en-US,en;q=0.9\"\n      },\n      \"rawHeaders\": [\n        \"Host\",\n        \"localhost:3000\",\n        \"Connection\",\n        \"keep-alive\",\n        \"Pragma\",\n        \"no-cache\",\n        \"Cache-Control\",\n        \"no-cache\",\n        \"User-Agent\",\n        \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"Accept\",\n        \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n        \"Sec-Fetch-Site\",\n        \"same-origin\",\n        \"Sec-Fetch-Mode\",\n        \"no-cors\",\n        \"Sec-Fetch-Dest\",\n        \"image\",\n        \"Accept-Encoding\",\n        \"gzip, deflate, br\",\n        \"Accept-Language\",\n        \"en-US,en;q=0.9\"\n      ],\n      \"trailers\": {},\n      \"rawTrailers\": [],\n      \"aborted\": false,\n      \"upgrade\": false,\n      \"url\": \"/favicon.ico\",\n      \"method\": \"GET\",\n      \"statusCode\": null,\n      \"statusMessage\": null,\n      \"client\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": false,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.client]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 34164\n        },\n        \"timeout\": 0\n      },\n      \"_consuming\": false,\n      \"_dumped\": false,\n      \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n      \"baseUrl\": \"\",\n      \"originalUrl\": \"/favicon.ico\",\n      \"_parsedUrl\": {\n        \"protocol\": null,\n        \"slashes\": null,\n        \"auth\": null,\n        \"host\": null,\n        \"port\": null,\n        \"hostname\": null,\n        \"hash\": null,\n        \"search\": null,\n        \"query\": null,\n        \"pathname\": \"/favicon.ico\",\n        \"path\": \"/favicon.ico\",\n        \"href\": \"/favicon.ico\",\n        \"_raw\": \"/favicon.ico\"\n      },\n      \"params\": {},\n      \"query\": {},\n      \"res\": \"[Circular ~.res]\",\n      \"body\": {},\n      \"_startAt\": [\n        118780,\n        37073485\n      ],\n      \"_startTime\": \"2020-11-30T04:23:32.838Z\",\n      \"_remoteAddress\": \"::1\"\n    },\n    \"locals\": {},\n    \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n    \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n    \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n    \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n    \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n    \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n  },\n  \"body\": {},\n  \"_startAt\": [\n    118780,\n    37073485\n  ],\n  \"_startTime\": \"2020-11-30T04:23:32.838Z\",\n  \"_remoteAddress\": \"::1\",\n  \"statusCode\" \u001b[31m[1]\u001b[0m: null\n}\n\u001b[31m\n[1] \"statusCode\" must be one of [400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511]\u001b[0m","level":"error","service":"monkey"}
{"message":"{\n  \"_readableState\": {\n    \"objectMode\": false,\n    \"highWaterMark\": 16384,\n    \"buffer\": {\n      \"head\": null,\n      \"tail\": null,\n      \"length\": 0\n    },\n    \"length\": 0,\n    \"pipes\": [],\n    \"flowing\": null,\n    \"ended\": false,\n    \"endEmitted\": false,\n    \"reading\": false,\n    \"sync\": true,\n    \"needReadable\": false,\n    \"emittedReadable\": false,\n    \"readableListening\": false,\n    \"resumeScheduled\": false,\n    \"errorEmitted\": false,\n    \"emitClose\": true,\n    \"autoDestroy\": false,\n    \"destroyed\": false,\n    \"errored\": null,\n    \"closed\": false,\n    \"closeEmitted\": false,\n    \"defaultEncoding\": \"utf8\",\n    \"awaitDrainWriters\": null,\n    \"multiAwaitDrain\": false,\n    \"readingMore\": true,\n    \"decoder\": null,\n    \"encoding\": null\n  },\n  \"_events\": {\n    \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n  },\n  \"_eventsCount\": 1,\n  \"socket\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": true,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.socket]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"cache-control\": \"max-age=0\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Cache-Control\",\n          \"max-age=0\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.socket]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.socket.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118812,\n          322012295\n        ],\n        \"_startTime\": \"2020-11-30T04:24:05.123Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.socket]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"cache-control\": \"max-age=0\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Cache-Control\",\n          \"max-age=0\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.socket._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118812,\n          322012295\n        ],\n        \"_startTime\": \"2020-11-30T04:24:05.123Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 34172\n    }\n  },\n  \"httpVersionMajor\": 1,\n  \"httpVersionMinor\": 1,\n  \"httpVersion\": \"1.1\",\n  \"complete\": false,\n  \"headers\": {\n    \"host\": \"localhost:3000\",\n    \"connection\": \"keep-alive\",\n    \"cache-control\": \"max-age=0\",\n    \"upgrade-insecure-requests\": \"1\",\n    \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n    \"sec-fetch-site\": \"none\",\n    \"sec-fetch-mode\": \"navigate\",\n    \"sec-fetch-user\": \"?1\",\n    \"sec-fetch-dest\": \"document\",\n    \"accept-encoding\": \"gzip, deflate, br\",\n    \"accept-language\": \"en-US,en;q=0.9\"\n  },\n  \"rawHeaders\": [\n    \"Host\",\n    \"localhost:3000\",\n    \"Connection\",\n    \"keep-alive\",\n    \"Cache-Control\",\n    \"max-age=0\",\n    \"Upgrade-Insecure-Requests\",\n    \"1\",\n    \"User-Agent\",\n    \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"Accept\",\n    \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n    \"Sec-Fetch-Site\",\n    \"none\",\n    \"Sec-Fetch-Mode\",\n    \"navigate\",\n    \"Sec-Fetch-User\",\n    \"?1\",\n    \"Sec-Fetch-Dest\",\n    \"document\",\n    \"Accept-Encoding\",\n    \"gzip, deflate, br\",\n    \"Accept-Language\",\n    \"en-US,en;q=0.9\"\n  ],\n  \"trailers\": {},\n  \"rawTrailers\": [],\n  \"aborted\": false,\n  \"upgrade\": false,\n  \"url\": \"/\",\n  \"method\": \"GET\",\n  \"statusMessage\": null,\n  \"client\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": true,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.client]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"cache-control\": \"max-age=0\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Cache-Control\",\n          \"max-age=0\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.client]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.client.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118812,\n          322012295\n        ],\n        \"_startTime\": \"2020-11-30T04:24:05.123Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.client]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"cache-control\": \"max-age=0\",\n          \"upgrade-insecure-requests\": \"1\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"sec-fetch-site\": \"none\",\n          \"sec-fetch-mode\": \"navigate\",\n          \"sec-fetch-user\": \"?1\",\n          \"sec-fetch-dest\": \"document\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Cache-Control\",\n          \"max-age=0\",\n          \"Upgrade-Insecure-Requests\",\n          \"1\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n          \"Sec-Fetch-Site\",\n          \"none\",\n          \"Sec-Fetch-Mode\",\n          \"navigate\",\n          \"Sec-Fetch-User\",\n          \"?1\",\n          \"Sec-Fetch-Dest\",\n          \"document\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/\",\n          \"path\": \"/\",\n          \"href\": \"/\",\n          \"_raw\": \"/\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.client._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118812,\n          322012295\n        ],\n        \"_startTime\": \"2020-11-30T04:24:05.123Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 34172\n    }\n  },\n  \"_consuming\": false,\n  \"_dumped\": false,\n  \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n  \"baseUrl\": \"\",\n  \"originalUrl\": \"/\",\n  \"_parsedUrl\": {\n    \"protocol\": null,\n    \"slashes\": null,\n    \"auth\": null,\n    \"host\": null,\n    \"port\": null,\n    \"hostname\": null,\n    \"hash\": null,\n    \"search\": null,\n    \"query\": null,\n    \"pathname\": \"/\",\n    \"path\": \"/\",\n    \"href\": \"/\",\n    \"_raw\": \"/\"\n  },\n  \"params\": {},\n  \"query\": {},\n  \"res\": {\n    \"_events\": {\n      \"finish\": [\n        function () { [native code] },\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n    },\n    \"_eventsCount\": 2,\n    \"outputData\": [],\n    \"outputSize\": 0,\n    \"writable\": true,\n    \"destroyed\": false,\n    \"_last\": false,\n    \"chunkedEncoding\": false,\n    \"shouldKeepAlive\": true,\n    \"_defaultKeepAlive\": true,\n    \"useChunkedEncodingByDefault\": true,\n    \"sendDate\": true,\n    \"_removedConnection\": false,\n    \"_removedContLen\": false,\n    \"_removedTE\": false,\n    \"_contentLength\": null,\n    \"_hasBody\": true,\n    \"_trailer\": \"\",\n    \"finished\": false,\n    \"_headerSent\": false,\n    \"socket\": {\n      \"connecting\": false,\n      \"_hadError\": false,\n      \"_parent\": null,\n      \"_host\": null,\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": true,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": true,\n        \"sync\": false,\n        \"needReadable\": true,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": false,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": [\n          function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n          function () { [native code] }\n        ],\n        \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n        \"data\": function () { [native code] },\n        \"error\": [\n          function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"close\": [\n          function () { [native code] },\n          function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"drain\": function () { [native code] },\n        \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n        \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n      },\n      \"_eventsCount\": 8,\n      \"_writableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"finalCalled\": false,\n        \"needDrain\": false,\n        \"ending\": false,\n        \"ended\": false,\n        \"finished\": false,\n        \"destroyed\": false,\n        \"decodeStrings\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"length\": 0,\n        \"writing\": false,\n        \"corked\": 0,\n        \"sync\": true,\n        \"bufferProcessing\": false,\n        \"onwrite\": function () { [native code] },\n        \"writecb\": null,\n        \"writelen\": 0,\n        \"afterWriteTickInfo\": null,\n        \"buffered\": [],\n        \"bufferedIndex\": 0,\n        \"allBuffers\": true,\n        \"allNoop\": true,\n        \"pendingcb\": 0,\n        \"prefinished\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false\n      },\n      \"allowHalfOpen\": true,\n      \"_sockname\": null,\n      \"_pendingData\": null,\n      \"_pendingEncoding\": \"\",\n      \"server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"_server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"parser\": {\n        \"0\": function () { [native code] },\n        \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n        \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n        \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n        \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n        \"5\": function () { [native code] },\n        \"6\": function () { [native code] },\n        \"_headers\": [],\n        \"_url\": \"\",\n        \"socket\": \"[Circular ~.res.socket]\",\n        \"incoming\": {\n          \"_readableState\": {\n            \"objectMode\": false,\n            \"highWaterMark\": 16384,\n            \"buffer\": {\n              \"head\": null,\n              \"tail\": null,\n              \"length\": 0\n            },\n            \"length\": 0,\n            \"pipes\": [],\n            \"flowing\": null,\n            \"ended\": false,\n            \"endEmitted\": false,\n            \"reading\": false,\n            \"sync\": true,\n            \"needReadable\": false,\n            \"emittedReadable\": false,\n            \"readableListening\": false,\n            \"resumeScheduled\": false,\n            \"errorEmitted\": false,\n            \"emitClose\": true,\n            \"autoDestroy\": false,\n            \"destroyed\": false,\n            \"errored\": null,\n            \"closed\": false,\n            \"closeEmitted\": false,\n            \"defaultEncoding\": \"utf8\",\n            \"awaitDrainWriters\": null,\n            \"multiAwaitDrain\": false,\n            \"readingMore\": true,\n            \"decoder\": null,\n            \"encoding\": null\n          },\n          \"_events\": {\n            \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n          },\n          \"_eventsCount\": 1,\n          \"socket\": \"[Circular ~.res.socket]\",\n          \"httpVersionMajor\": 1,\n          \"httpVersionMinor\": 1,\n          \"httpVersion\": \"1.1\",\n          \"complete\": false,\n          \"headers\": {\n            \"host\": \"localhost:3000\",\n            \"connection\": \"keep-alive\",\n            \"cache-control\": \"max-age=0\",\n            \"upgrade-insecure-requests\": \"1\",\n            \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n            \"sec-fetch-site\": \"none\",\n            \"sec-fetch-mode\": \"navigate\",\n            \"sec-fetch-user\": \"?1\",\n            \"sec-fetch-dest\": \"document\",\n            \"accept-encoding\": \"gzip, deflate, br\",\n            \"accept-language\": \"en-US,en;q=0.9\"\n          },\n          \"rawHeaders\": [\n            \"Host\",\n            \"localhost:3000\",\n            \"Connection\",\n            \"keep-alive\",\n            \"Cache-Control\",\n            \"max-age=0\",\n            \"Upgrade-Insecure-Requests\",\n            \"1\",\n            \"User-Agent\",\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"Accept\",\n            \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n            \"Sec-Fetch-Site\",\n            \"none\",\n            \"Sec-Fetch-Mode\",\n            \"navigate\",\n            \"Sec-Fetch-User\",\n            \"?1\",\n            \"Sec-Fetch-Dest\",\n            \"document\",\n            \"Accept-Encoding\",\n            \"gzip, deflate, br\",\n            \"Accept-Language\",\n            \"en-US,en;q=0.9\"\n          ],\n          \"trailers\": {},\n          \"rawTrailers\": [],\n          \"aborted\": false,\n          \"upgrade\": false,\n          \"url\": \"/\",\n          \"method\": \"GET\",\n          \"statusCode\": null,\n          \"statusMessage\": null,\n          \"client\": \"[Circular ~.res.socket]\",\n          \"_consuming\": false,\n          \"_dumped\": false,\n          \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n          \"baseUrl\": \"\",\n          \"originalUrl\": \"/\",\n          \"_parsedUrl\": {\n            \"protocol\": null,\n            \"slashes\": null,\n            \"auth\": null,\n            \"host\": null,\n            \"port\": null,\n            \"hostname\": null,\n            \"hash\": null,\n            \"search\": null,\n            \"query\": null,\n            \"pathname\": \"/\",\n            \"path\": \"/\",\n            \"href\": \"/\",\n            \"_raw\": \"/\"\n          },\n          \"params\": {},\n          \"query\": {},\n          \"res\": \"[Circular ~.res]\",\n          \"body\": {},\n          \"_startAt\": [\n            118812,\n            322012295\n          ],\n          \"_startTime\": \"2020-11-30T04:24:05.123Z\",\n          \"_remoteAddress\": \"::1\"\n        },\n        \"outgoing\": null,\n        \"maxHeaderPairs\": 2000,\n        \"_consumed\": true,\n        \"onIncoming\": function () { [native code] }\n      },\n      \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"_paused\": false,\n      \"_httpMessage\": \"[Circular ~.res]\",\n      \"_peername\": {\n        \"address\": \"::1\",\n        \"family\": \"IPv6\",\n        \"port\": 34172\n      }\n    },\n    \"_header\": null,\n    \"_keepAliveTimeout\": 5000,\n    \"_onPendingData\": function () { [native code] },\n    \"_sent100\": false,\n    \"_expect_continue\": false,\n    \"req\": {\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": null,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": false,\n        \"sync\": true,\n        \"needReadable\": false,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": true,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": true,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n      },\n      \"_eventsCount\": 1,\n      \"socket\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": true,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.socket]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 34172\n        }\n      },\n      \"httpVersionMajor\": 1,\n      \"httpVersionMinor\": 1,\n      \"httpVersion\": \"1.1\",\n      \"complete\": false,\n      \"headers\": {\n        \"host\": \"localhost:3000\",\n        \"connection\": \"keep-alive\",\n        \"cache-control\": \"max-age=0\",\n        \"upgrade-insecure-requests\": \"1\",\n        \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n        \"sec-fetch-site\": \"none\",\n        \"sec-fetch-mode\": \"navigate\",\n        \"sec-fetch-user\": \"?1\",\n        \"sec-fetch-dest\": \"document\",\n        \"accept-encoding\": \"gzip, deflate, br\",\n        \"accept-language\": \"en-US,en;q=0.9\"\n      },\n      \"rawHeaders\": [\n        \"Host\",\n        \"localhost:3000\",\n        \"Connection\",\n        \"keep-alive\",\n        \"Cache-Control\",\n        \"max-age=0\",\n        \"Upgrade-Insecure-Requests\",\n        \"1\",\n        \"User-Agent\",\n        \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"Accept\",\n        \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n        \"Sec-Fetch-Site\",\n        \"none\",\n        \"Sec-Fetch-Mode\",\n        \"navigate\",\n        \"Sec-Fetch-User\",\n        \"?1\",\n        \"Sec-Fetch-Dest\",\n        \"document\",\n        \"Accept-Encoding\",\n        \"gzip, deflate, br\",\n        \"Accept-Language\",\n        \"en-US,en;q=0.9\"\n      ],\n      \"trailers\": {},\n      \"rawTrailers\": [],\n      \"aborted\": false,\n      \"upgrade\": false,\n      \"url\": \"/\",\n      \"method\": \"GET\",\n      \"statusCode\": null,\n      \"statusMessage\": null,\n      \"client\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": true,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.client]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 34172\n        }\n      },\n      \"_consuming\": false,\n      \"_dumped\": false,\n      \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n      \"baseUrl\": \"\",\n      \"originalUrl\": \"/\",\n      \"_parsedUrl\": {\n        \"protocol\": null,\n        \"slashes\": null,\n        \"auth\": null,\n        \"host\": null,\n        \"port\": null,\n        \"hostname\": null,\n        \"hash\": null,\n        \"search\": null,\n        \"query\": null,\n        \"pathname\": \"/\",\n        \"path\": \"/\",\n        \"href\": \"/\",\n        \"_raw\": \"/\"\n      },\n      \"params\": {},\n      \"query\": {},\n      \"res\": \"[Circular ~.res]\",\n      \"body\": {},\n      \"_startAt\": [\n        118812,\n        322012295\n      ],\n      \"_startTime\": \"2020-11-30T04:24:05.123Z\",\n      \"_remoteAddress\": \"::1\"\n    },\n    \"locals\": {},\n    \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n    \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n    \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n    \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n    \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n    \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n  },\n  \"body\": {},\n  \"_startAt\": [\n    118812,\n    322012295\n  ],\n  \"_startTime\": \"2020-11-30T04:24:05.123Z\",\n  \"_remoteAddress\": \"::1\",\n  \"statusCode\" \u001b[31m[1]\u001b[0m: null\n}\n\u001b[31m\n[1] \"statusCode\" must be one of [400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511]\u001b[0m","level":"error","service":"monkey"}
{"message":"{\n  \"_readableState\": {\n    \"objectMode\": false,\n    \"highWaterMark\": 16384,\n    \"buffer\": {\n      \"head\": null,\n      \"tail\": null,\n      \"length\": 0\n    },\n    \"length\": 0,\n    \"pipes\": [],\n    \"flowing\": null,\n    \"ended\": false,\n    \"endEmitted\": false,\n    \"reading\": false,\n    \"sync\": true,\n    \"needReadable\": false,\n    \"emittedReadable\": false,\n    \"readableListening\": false,\n    \"resumeScheduled\": false,\n    \"errorEmitted\": false,\n    \"emitClose\": true,\n    \"autoDestroy\": false,\n    \"destroyed\": false,\n    \"errored\": null,\n    \"closed\": false,\n    \"closeEmitted\": false,\n    \"defaultEncoding\": \"utf8\",\n    \"awaitDrainWriters\": null,\n    \"multiAwaitDrain\": false,\n    \"readingMore\": true,\n    \"decoder\": null,\n    \"encoding\": null\n  },\n  \"_events\": {\n    \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n  },\n  \"_eventsCount\": 1,\n  \"socket\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": false,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.socket]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"pragma\": \"no-cache\",\n          \"cache-control\": \"no-cache\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Pragma\",\n          \"no-cache\",\n          \"Cache-Control\",\n          \"no-cache\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.socket]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.socket.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118812,\n          478117665\n        ],\n        \"_startTime\": \"2020-11-30T04:24:05.279Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.socket]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.socket]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"pragma\": \"no-cache\",\n          \"cache-control\": \"no-cache\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Pragma\",\n          \"no-cache\",\n          \"Cache-Control\",\n          \"no-cache\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.socket]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.socket._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118812,\n          478117665\n        ],\n        \"_startTime\": \"2020-11-30T04:24:05.279Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 34172\n    },\n    \"timeout\": 0\n  },\n  \"httpVersionMajor\": 1,\n  \"httpVersionMinor\": 1,\n  \"httpVersion\": \"1.1\",\n  \"complete\": false,\n  \"headers\": {\n    \"host\": \"localhost:3000\",\n    \"connection\": \"keep-alive\",\n    \"pragma\": \"no-cache\",\n    \"cache-control\": \"no-cache\",\n    \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n    \"sec-fetch-site\": \"same-origin\",\n    \"sec-fetch-mode\": \"no-cors\",\n    \"sec-fetch-dest\": \"image\",\n    \"accept-encoding\": \"gzip, deflate, br\",\n    \"accept-language\": \"en-US,en;q=0.9\"\n  },\n  \"rawHeaders\": [\n    \"Host\",\n    \"localhost:3000\",\n    \"Connection\",\n    \"keep-alive\",\n    \"Pragma\",\n    \"no-cache\",\n    \"Cache-Control\",\n    \"no-cache\",\n    \"User-Agent\",\n    \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n    \"Accept\",\n    \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n    \"Sec-Fetch-Site\",\n    \"same-origin\",\n    \"Sec-Fetch-Mode\",\n    \"no-cors\",\n    \"Sec-Fetch-Dest\",\n    \"image\",\n    \"Accept-Encoding\",\n    \"gzip, deflate, br\",\n    \"Accept-Language\",\n    \"en-US,en;q=0.9\"\n  ],\n  \"trailers\": {},\n  \"rawTrailers\": [],\n  \"aborted\": false,\n  \"upgrade\": false,\n  \"url\": \"/favicon.ico\",\n  \"method\": \"GET\",\n  \"statusMessage\": null,\n  \"client\": {\n    \"connecting\": false,\n    \"_hadError\": false,\n    \"_parent\": null,\n    \"_host\": null,\n    \"_readableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"buffer\": {\n        \"head\": null,\n        \"tail\": null,\n        \"length\": 0\n      },\n      \"length\": 0,\n      \"pipes\": [],\n      \"flowing\": true,\n      \"ended\": false,\n      \"endEmitted\": false,\n      \"reading\": true,\n      \"sync\": false,\n      \"needReadable\": true,\n      \"emittedReadable\": false,\n      \"readableListening\": false,\n      \"resumeScheduled\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"destroyed\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"awaitDrainWriters\": null,\n      \"multiAwaitDrain\": false,\n      \"readingMore\": false,\n      \"decoder\": null,\n      \"encoding\": null\n    },\n    \"_events\": {\n      \"end\": [\n        function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n        function () { [native code] }\n      ],\n      \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n      \"data\": function () { [native code] },\n      \"error\": [\n        function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"close\": [\n        function () { [native code] },\n        function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"drain\": function () { [native code] },\n      \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n      \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n    },\n    \"_eventsCount\": 8,\n    \"_writableState\": {\n      \"objectMode\": false,\n      \"highWaterMark\": 16384,\n      \"finalCalled\": false,\n      \"needDrain\": false,\n      \"ending\": false,\n      \"ended\": false,\n      \"finished\": false,\n      \"destroyed\": false,\n      \"decodeStrings\": false,\n      \"defaultEncoding\": \"utf8\",\n      \"length\": 0,\n      \"writing\": false,\n      \"corked\": 0,\n      \"sync\": false,\n      \"bufferProcessing\": false,\n      \"onwrite\": function () { [native code] },\n      \"writecb\": null,\n      \"writelen\": 0,\n      \"afterWriteTickInfo\": null,\n      \"buffered\": [],\n      \"bufferedIndex\": 0,\n      \"allBuffers\": true,\n      \"allNoop\": true,\n      \"pendingcb\": 0,\n      \"prefinished\": false,\n      \"errorEmitted\": false,\n      \"emitClose\": false,\n      \"autoDestroy\": false,\n      \"errored\": null,\n      \"closed\": false,\n      \"closeEmitted\": false\n    },\n    \"allowHalfOpen\": true,\n    \"_sockname\": null,\n    \"_pendingData\": null,\n    \"_pendingEncoding\": \"\",\n    \"server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"_server\": {\n      \"_events\": {\n        \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n        \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n      },\n      \"_eventsCount\": 2,\n      \"_connections\": 2,\n      \"_handle\": {\n        \"reading\": false,\n        \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n      },\n      \"_usingWorkers\": false,\n      \"_workers\": [],\n      \"_unref\": false,\n      \"allowHalfOpen\": true,\n      \"pauseOnConnect\": false,\n      \"httpAllowHalfOpen\": false,\n      \"timeout\": 0,\n      \"keepAliveTimeout\": 5000,\n      \"maxHeadersCount\": null,\n      \"headersTimeout\": 60000,\n      \"requestTimeout\": 0,\n      \"_connectionKey\": \"6::::3000\"\n    },\n    \"parser\": {\n      \"0\": function () { [native code] },\n      \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n      \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n      \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n      \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n      \"5\": function () { [native code] },\n      \"6\": function () { [native code] },\n      \"_headers\": [],\n      \"_url\": \"\",\n      \"socket\": \"[Circular ~.client]\",\n      \"incoming\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"pragma\": \"no-cache\",\n          \"cache-control\": \"no-cache\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Pragma\",\n          \"no-cache\",\n          \"Cache-Control\",\n          \"no-cache\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": {\n          \"_events\": {\n            \"finish\": [\n              function () { [native code] },\n              function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n            ],\n            \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          },\n          \"_eventsCount\": 2,\n          \"outputData\": [],\n          \"outputSize\": 0,\n          \"writable\": true,\n          \"destroyed\": false,\n          \"_last\": false,\n          \"chunkedEncoding\": false,\n          \"shouldKeepAlive\": true,\n          \"_defaultKeepAlive\": true,\n          \"useChunkedEncodingByDefault\": true,\n          \"sendDate\": true,\n          \"_removedConnection\": false,\n          \"_removedContLen\": false,\n          \"_removedTE\": false,\n          \"_contentLength\": null,\n          \"_hasBody\": true,\n          \"_trailer\": \"\",\n          \"finished\": false,\n          \"_headerSent\": false,\n          \"socket\": \"[Circular ~.client]\",\n          \"_header\": null,\n          \"_keepAliveTimeout\": 5000,\n          \"_onPendingData\": function () { [native code] },\n          \"_sent100\": false,\n          \"_expect_continue\": false,\n          \"req\": \"[Circular ~.client.parser.incoming]\",\n          \"locals\": {},\n          \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n          \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n          \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n          \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n          \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n          \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n        },\n        \"body\": {},\n        \"_startAt\": [\n          118812,\n          478117665\n        ],\n        \"_startTime\": \"2020-11-30T04:24:05.279Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"outgoing\": null,\n      \"maxHeaderPairs\": 2000,\n      \"_consumed\": true,\n      \"onIncoming\": function () { [native code] }\n    },\n    \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n    \"_paused\": false,\n    \"_httpMessage\": {\n      \"_events\": {\n        \"finish\": [\n          function () { [native code] },\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      },\n      \"_eventsCount\": 2,\n      \"outputData\": [],\n      \"outputSize\": 0,\n      \"writable\": true,\n      \"destroyed\": false,\n      \"_last\": false,\n      \"chunkedEncoding\": false,\n      \"shouldKeepAlive\": true,\n      \"_defaultKeepAlive\": true,\n      \"useChunkedEncodingByDefault\": true,\n      \"sendDate\": true,\n      \"_removedConnection\": false,\n      \"_removedContLen\": false,\n      \"_removedTE\": false,\n      \"_contentLength\": null,\n      \"_hasBody\": true,\n      \"_trailer\": \"\",\n      \"finished\": false,\n      \"_headerSent\": false,\n      \"socket\": \"[Circular ~.client]\",\n      \"_header\": null,\n      \"_keepAliveTimeout\": 5000,\n      \"_onPendingData\": function () { [native code] },\n      \"_sent100\": false,\n      \"_expect_continue\": false,\n      \"req\": {\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": null,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": false,\n          \"sync\": true,\n          \"needReadable\": false,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": true,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": true,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n        },\n        \"_eventsCount\": 1,\n        \"socket\": \"[Circular ~.client]\",\n        \"httpVersionMajor\": 1,\n        \"httpVersionMinor\": 1,\n        \"httpVersion\": \"1.1\",\n        \"complete\": false,\n        \"headers\": {\n          \"host\": \"localhost:3000\",\n          \"connection\": \"keep-alive\",\n          \"pragma\": \"no-cache\",\n          \"cache-control\": \"no-cache\",\n          \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"sec-fetch-site\": \"same-origin\",\n          \"sec-fetch-mode\": \"no-cors\",\n          \"sec-fetch-dest\": \"image\",\n          \"accept-encoding\": \"gzip, deflate, br\",\n          \"accept-language\": \"en-US,en;q=0.9\"\n        },\n        \"rawHeaders\": [\n          \"Host\",\n          \"localhost:3000\",\n          \"Connection\",\n          \"keep-alive\",\n          \"Pragma\",\n          \"no-cache\",\n          \"Cache-Control\",\n          \"no-cache\",\n          \"User-Agent\",\n          \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n          \"Accept\",\n          \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n          \"Sec-Fetch-Site\",\n          \"same-origin\",\n          \"Sec-Fetch-Mode\",\n          \"no-cors\",\n          \"Sec-Fetch-Dest\",\n          \"image\",\n          \"Accept-Encoding\",\n          \"gzip, deflate, br\",\n          \"Accept-Language\",\n          \"en-US,en;q=0.9\"\n        ],\n        \"trailers\": {},\n        \"rawTrailers\": [],\n        \"aborted\": false,\n        \"upgrade\": false,\n        \"url\": \"/favicon.ico\",\n        \"method\": \"GET\",\n        \"statusCode\": null,\n        \"statusMessage\": null,\n        \"client\": \"[Circular ~.client]\",\n        \"_consuming\": false,\n        \"_dumped\": false,\n        \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n        \"baseUrl\": \"\",\n        \"originalUrl\": \"/favicon.ico\",\n        \"_parsedUrl\": {\n          \"protocol\": null,\n          \"slashes\": null,\n          \"auth\": null,\n          \"host\": null,\n          \"port\": null,\n          \"hostname\": null,\n          \"hash\": null,\n          \"search\": null,\n          \"query\": null,\n          \"pathname\": \"/favicon.ico\",\n          \"path\": \"/favicon.ico\",\n          \"href\": \"/favicon.ico\",\n          \"_raw\": \"/favicon.ico\"\n        },\n        \"params\": {},\n        \"query\": {},\n        \"res\": \"[Circular ~.client._httpMessage]\",\n        \"body\": {},\n        \"_startAt\": [\n          118812,\n          478117665\n        ],\n        \"_startTime\": \"2020-11-30T04:24:05.279Z\",\n        \"_remoteAddress\": \"::1\"\n      },\n      \"locals\": {},\n      \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n      \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n      \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n      \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n      \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n      \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n    },\n    \"_peername\": {\n      \"address\": \"::1\",\n      \"family\": \"IPv6\",\n      \"port\": 34172\n    },\n    \"timeout\": 0\n  },\n  \"_consuming\": false,\n  \"_dumped\": false,\n  \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n  \"baseUrl\": \"\",\n  \"originalUrl\": \"/favicon.ico\",\n  \"_parsedUrl\": {\n    \"protocol\": null,\n    \"slashes\": null,\n    \"auth\": null,\n    \"host\": null,\n    \"port\": null,\n    \"hostname\": null,\n    \"hash\": null,\n    \"search\": null,\n    \"query\": null,\n    \"pathname\": \"/favicon.ico\",\n    \"path\": \"/favicon.ico\",\n    \"href\": \"/favicon.ico\",\n    \"_raw\": \"/favicon.ico\"\n  },\n  \"params\": {},\n  \"query\": {},\n  \"res\": {\n    \"_events\": {\n      \"finish\": [\n        function () { [native code] },\n        function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n      ],\n      \"end\": function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n    },\n    \"_eventsCount\": 2,\n    \"outputData\": [],\n    \"outputSize\": 0,\n    \"writable\": true,\n    \"destroyed\": false,\n    \"_last\": false,\n    \"chunkedEncoding\": false,\n    \"shouldKeepAlive\": true,\n    \"_defaultKeepAlive\": true,\n    \"useChunkedEncodingByDefault\": true,\n    \"sendDate\": true,\n    \"_removedConnection\": false,\n    \"_removedContLen\": false,\n    \"_removedTE\": false,\n    \"_contentLength\": null,\n    \"_hasBody\": true,\n    \"_trailer\": \"\",\n    \"finished\": false,\n    \"_headerSent\": false,\n    \"socket\": {\n      \"connecting\": false,\n      \"_hadError\": false,\n      \"_parent\": null,\n      \"_host\": null,\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": true,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": true,\n        \"sync\": false,\n        \"needReadable\": true,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": false,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": [\n          function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n          function () { [native code] }\n        ],\n        \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n        \"data\": function () { [native code] },\n        \"error\": [\n          function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"close\": [\n          function () { [native code] },\n          function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n          function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n        ],\n        \"drain\": function () { [native code] },\n        \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n        \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n      },\n      \"_eventsCount\": 8,\n      \"_writableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"finalCalled\": false,\n        \"needDrain\": false,\n        \"ending\": false,\n        \"ended\": false,\n        \"finished\": false,\n        \"destroyed\": false,\n        \"decodeStrings\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"length\": 0,\n        \"writing\": false,\n        \"corked\": 0,\n        \"sync\": false,\n        \"bufferProcessing\": false,\n        \"onwrite\": function () { [native code] },\n        \"writecb\": null,\n        \"writelen\": 0,\n        \"afterWriteTickInfo\": null,\n        \"buffered\": [],\n        \"bufferedIndex\": 0,\n        \"allBuffers\": true,\n        \"allNoop\": true,\n        \"pendingcb\": 0,\n        \"prefinished\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": false,\n        \"autoDestroy\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false\n      },\n      \"allowHalfOpen\": true,\n      \"_sockname\": null,\n      \"_pendingData\": null,\n      \"_pendingEncoding\": \"\",\n      \"server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"_server\": {\n        \"_events\": {\n          \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n          \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n        },\n        \"_eventsCount\": 2,\n        \"_connections\": 2,\n        \"_handle\": {\n          \"reading\": false,\n          \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n        },\n        \"_usingWorkers\": false,\n        \"_workers\": [],\n        \"_unref\": false,\n        \"allowHalfOpen\": true,\n        \"pauseOnConnect\": false,\n        \"httpAllowHalfOpen\": false,\n        \"timeout\": 0,\n        \"keepAliveTimeout\": 5000,\n        \"maxHeadersCount\": null,\n        \"headersTimeout\": 60000,\n        \"requestTimeout\": 0,\n        \"_connectionKey\": \"6::::3000\"\n      },\n      \"parser\": {\n        \"0\": function () { [native code] },\n        \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n        \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n        \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n        \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n        \"5\": function () { [native code] },\n        \"6\": function () { [native code] },\n        \"_headers\": [],\n        \"_url\": \"\",\n        \"socket\": \"[Circular ~.res.socket]\",\n        \"incoming\": {\n          \"_readableState\": {\n            \"objectMode\": false,\n            \"highWaterMark\": 16384,\n            \"buffer\": {\n              \"head\": null,\n              \"tail\": null,\n              \"length\": 0\n            },\n            \"length\": 0,\n            \"pipes\": [],\n            \"flowing\": null,\n            \"ended\": false,\n            \"endEmitted\": false,\n            \"reading\": false,\n            \"sync\": true,\n            \"needReadable\": false,\n            \"emittedReadable\": false,\n            \"readableListening\": false,\n            \"resumeScheduled\": false,\n            \"errorEmitted\": false,\n            \"emitClose\": true,\n            \"autoDestroy\": false,\n            \"destroyed\": false,\n            \"errored\": null,\n            \"closed\": false,\n            \"closeEmitted\": false,\n            \"defaultEncoding\": \"utf8\",\n            \"awaitDrainWriters\": null,\n            \"multiAwaitDrain\": false,\n            \"readingMore\": true,\n            \"decoder\": null,\n            \"encoding\": null\n          },\n          \"_events\": {\n            \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n          },\n          \"_eventsCount\": 1,\n          \"socket\": \"[Circular ~.res.socket]\",\n          \"httpVersionMajor\": 1,\n          \"httpVersionMinor\": 1,\n          \"httpVersion\": \"1.1\",\n          \"complete\": false,\n          \"headers\": {\n            \"host\": \"localhost:3000\",\n            \"connection\": \"keep-alive\",\n            \"pragma\": \"no-cache\",\n            \"cache-control\": \"no-cache\",\n            \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n            \"sec-fetch-site\": \"same-origin\",\n            \"sec-fetch-mode\": \"no-cors\",\n            \"sec-fetch-dest\": \"image\",\n            \"accept-encoding\": \"gzip, deflate, br\",\n            \"accept-language\": \"en-US,en;q=0.9\"\n          },\n          \"rawHeaders\": [\n            \"Host\",\n            \"localhost:3000\",\n            \"Connection\",\n            \"keep-alive\",\n            \"Pragma\",\n            \"no-cache\",\n            \"Cache-Control\",\n            \"no-cache\",\n            \"User-Agent\",\n            \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n            \"Accept\",\n            \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n            \"Sec-Fetch-Site\",\n            \"same-origin\",\n            \"Sec-Fetch-Mode\",\n            \"no-cors\",\n            \"Sec-Fetch-Dest\",\n            \"image\",\n            \"Accept-Encoding\",\n            \"gzip, deflate, br\",\n            \"Accept-Language\",\n            \"en-US,en;q=0.9\"\n          ],\n          \"trailers\": {},\n          \"rawTrailers\": [],\n          \"aborted\": false,\n          \"upgrade\": false,\n          \"url\": \"/favicon.ico\",\n          \"method\": \"GET\",\n          \"statusCode\": null,\n          \"statusMessage\": null,\n          \"client\": \"[Circular ~.res.socket]\",\n          \"_consuming\": false,\n          \"_dumped\": false,\n          \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n          \"baseUrl\": \"\",\n          \"originalUrl\": \"/favicon.ico\",\n          \"_parsedUrl\": {\n            \"protocol\": null,\n            \"slashes\": null,\n            \"auth\": null,\n            \"host\": null,\n            \"port\": null,\n            \"hostname\": null,\n            \"hash\": null,\n            \"search\": null,\n            \"query\": null,\n            \"pathname\": \"/favicon.ico\",\n            \"path\": \"/favicon.ico\",\n            \"href\": \"/favicon.ico\",\n            \"_raw\": \"/favicon.ico\"\n          },\n          \"params\": {},\n          \"query\": {},\n          \"res\": \"[Circular ~.res]\",\n          \"body\": {},\n          \"_startAt\": [\n            118812,\n            478117665\n          ],\n          \"_startTime\": \"2020-11-30T04:24:05.279Z\",\n          \"_remoteAddress\": \"::1\"\n        },\n        \"outgoing\": null,\n        \"maxHeaderPairs\": 2000,\n        \"_consumed\": true,\n        \"onIncoming\": function () { [native code] }\n      },\n      \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n      \"_paused\": false,\n      \"_httpMessage\": \"[Circular ~.res]\",\n      \"_peername\": {\n        \"address\": \"::1\",\n        \"family\": \"IPv6\",\n        \"port\": 34172\n      },\n      \"timeout\": 0\n    },\n    \"_header\": null,\n    \"_keepAliveTimeout\": 5000,\n    \"_onPendingData\": function () { [native code] },\n    \"_sent100\": false,\n    \"_expect_continue\": false,\n    \"req\": {\n      \"_readableState\": {\n        \"objectMode\": false,\n        \"highWaterMark\": 16384,\n        \"buffer\": {\n          \"head\": null,\n          \"tail\": null,\n          \"length\": 0\n        },\n        \"length\": 0,\n        \"pipes\": [],\n        \"flowing\": null,\n        \"ended\": false,\n        \"endEmitted\": false,\n        \"reading\": false,\n        \"sync\": true,\n        \"needReadable\": false,\n        \"emittedReadable\": false,\n        \"readableListening\": false,\n        \"resumeScheduled\": false,\n        \"errorEmitted\": false,\n        \"emitClose\": true,\n        \"autoDestroy\": false,\n        \"destroyed\": false,\n        \"errored\": null,\n        \"closed\": false,\n        \"closeEmitted\": false,\n        \"defaultEncoding\": \"utf8\",\n        \"awaitDrainWriters\": null,\n        \"multiAwaitDrain\": false,\n        \"readingMore\": true,\n        \"decoder\": null,\n        \"encoding\": null\n      },\n      \"_events\": {\n        \"end\": function clearRequestTimeout(req) {\\n  if (!req) {\\n    req = this;\\n  }\\n\\n  if (!req[kRequestTimeout]) {\\n    return;\\n  }\\n\\n  debug('requestTimeout timer cleared');\\n  clearTimeout(req[kRequestTimeout]);\\n  req[kRequestTimeout] = undefined;\\n}\n      },\n      \"_eventsCount\": 1,\n      \"socket\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": false,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.socket]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 34172\n        },\n        \"timeout\": 0\n      },\n      \"httpVersionMajor\": 1,\n      \"httpVersionMinor\": 1,\n      \"httpVersion\": \"1.1\",\n      \"complete\": false,\n      \"headers\": {\n        \"host\": \"localhost:3000\",\n        \"connection\": \"keep-alive\",\n        \"pragma\": \"no-cache\",\n        \"cache-control\": \"no-cache\",\n        \"user-agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"accept\": \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n        \"sec-fetch-site\": \"same-origin\",\n        \"sec-fetch-mode\": \"no-cors\",\n        \"sec-fetch-dest\": \"image\",\n        \"accept-encoding\": \"gzip, deflate, br\",\n        \"accept-language\": \"en-US,en;q=0.9\"\n      },\n      \"rawHeaders\": [\n        \"Host\",\n        \"localhost:3000\",\n        \"Connection\",\n        \"keep-alive\",\n        \"Pragma\",\n        \"no-cache\",\n        \"Cache-Control\",\n        \"no-cache\",\n        \"User-Agent\",\n        \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4321.0 Safari/537.36 Edg/88.0.702.0\",\n        \"Accept\",\n        \"image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8\",\n        \"Sec-Fetch-Site\",\n        \"same-origin\",\n        \"Sec-Fetch-Mode\",\n        \"no-cors\",\n        \"Sec-Fetch-Dest\",\n        \"image\",\n        \"Accept-Encoding\",\n        \"gzip, deflate, br\",\n        \"Accept-Language\",\n        \"en-US,en;q=0.9\"\n      ],\n      \"trailers\": {},\n      \"rawTrailers\": [],\n      \"aborted\": false,\n      \"upgrade\": false,\n      \"url\": \"/favicon.ico\",\n      \"method\": \"GET\",\n      \"statusCode\": null,\n      \"statusMessage\": null,\n      \"client\": {\n        \"connecting\": false,\n        \"_hadError\": false,\n        \"_parent\": null,\n        \"_host\": null,\n        \"_readableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"buffer\": {\n            \"head\": null,\n            \"tail\": null,\n            \"length\": 0\n          },\n          \"length\": 0,\n          \"pipes\": [],\n          \"flowing\": true,\n          \"ended\": false,\n          \"endEmitted\": false,\n          \"reading\": true,\n          \"sync\": false,\n          \"needReadable\": true,\n          \"emittedReadable\": false,\n          \"readableListening\": false,\n          \"resumeScheduled\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"destroyed\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"awaitDrainWriters\": null,\n          \"multiAwaitDrain\": false,\n          \"readingMore\": false,\n          \"decoder\": null,\n          \"encoding\": null\n        },\n        \"_events\": {\n          \"end\": [\n            function onReadableStreamEnd() {\\n  if (!this.allowHalfOpen) {\\n    this.write = writeAfterFIN;\\n    if (this.writable)\\n      this.end();\\n    else if (!this.writableLength)\\n      this.destroy();\\n  } else if (!this.destroyed && !this.writable && !this.writableLength)\\n    this.destroy();\\n},\n            function () { [native code] }\n          ],\n          \"timeout\": function socketOnTimeout() {\\n  const req = this.parser && this.parser.incoming;\\n  const reqTimeout = req && !req.complete && req.emit('timeout', this);\\n  const res = this._httpMessage;\\n  const resTimeout = res && res.emit('timeout', this);\\n  const serverTimeout = this.server.emit('timeout', this);\\n\\n  if (!reqTimeout && !resTimeout && !serverTimeout)\\n    this.destroy();\\n},\n          \"data\": function () { [native code] },\n          \"error\": [\n            function socketOnError(e) {\\n  // Ignore further errors\\n  this.removeListener('error', socketOnError);\\n  this.on('error', noop);\\n\\n  if (!this.server.emit('clientError', e, this)) {\\n    if (this.writable && this.bytesWritten === 0) {\\n      let response;\\n\\n      switch (e.code) {\\n        case 'HPE_HEADER_OVERFLOW':\\n          response = requestHeaderFieldsTooLargeResponse;\\n          break;\\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\\n          response = requestTimeoutResponse;\\n          break;\\n        default:\\n          response = badRequestResponse;\\n          break;\\n      }\\n\\n      this.write(response);\\n    }\\n    this.destroy(e);\\n  }\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"close\": [\n            function () { [native code] },\n            function onServerResponseClose() {\\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\\n  // listener, onServerResponseClose is still in that copy of the listeners\\n  // array. That is, in the example below, b still gets called even though\\n  // it's been removed by a:\\n  //\\n  //   var EventEmitter = require('events');\\n  //   var obj = new EventEmitter();\\n  //   obj.on('event', a);\\n  //   obj.on('event', b);\\n  //   function a() { obj.removeListener('event', b) }\\n  //   function b() { throw \\\"BAM!\\\" }\\n  //   obj.emit('event');  // throws\\n  //\\n  // Ergo, we need to deal with stale 'close' events and handle the case\\n  // where the ServerResponse object has already been deconstructed.\\n  // Fortunately, that requires only a single if check. :-)\\n  if (this._httpMessage) this._httpMessage.emit('close');\\n},\n            function onevent(arg1) {\\n    var args = new Array(arguments.length)\\n    var ee = this\\n    var err = event === 'error'\\n      ? arg1\\n      : null\\n\\n    // copy args to prevent arguments escaping scope\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i]\\n    }\\n\\n    done(err, ee, event, args)\\n  }\n          ],\n          \"drain\": function () { [native code] },\n          \"resume\": function onSocketResume() {\\n  // It may seem that the socket is resumed, but this is an enemy's trick to\\n  // deceive us! `resume` is emitted asynchronously, and may be called from\\n  // `incoming.readStart()`. Stop the socket again here, just to preserve the\\n  // state.\\n  //\\n  // We don't care about stream semantics for the consumed socket anyway.\\n  if (this._paused) {\\n    this.pause();\\n    return;\\n  }\\n\\n  if (this._handle && !this._handle.reading) {\\n    this._handle.reading = true;\\n    this._handle.readStart();\\n  }\\n},\n          \"pause\": function onSocketPause() {\\n  if (this._handle && this._handle.reading) {\\n    this._handle.reading = false;\\n    this._handle.readStop();\\n  }\\n}\n        },\n        \"_eventsCount\": 8,\n        \"_writableState\": {\n          \"objectMode\": false,\n          \"highWaterMark\": 16384,\n          \"finalCalled\": false,\n          \"needDrain\": false,\n          \"ending\": false,\n          \"ended\": false,\n          \"finished\": false,\n          \"destroyed\": false,\n          \"decodeStrings\": false,\n          \"defaultEncoding\": \"utf8\",\n          \"length\": 0,\n          \"writing\": false,\n          \"corked\": 0,\n          \"sync\": false,\n          \"bufferProcessing\": false,\n          \"onwrite\": function () { [native code] },\n          \"writecb\": null,\n          \"writelen\": 0,\n          \"afterWriteTickInfo\": null,\n          \"buffered\": [],\n          \"bufferedIndex\": 0,\n          \"allBuffers\": true,\n          \"allNoop\": true,\n          \"pendingcb\": 0,\n          \"prefinished\": false,\n          \"errorEmitted\": false,\n          \"emitClose\": false,\n          \"autoDestroy\": false,\n          \"errored\": null,\n          \"closed\": false,\n          \"closeEmitted\": false\n        },\n        \"allowHalfOpen\": true,\n        \"_sockname\": null,\n        \"_pendingData\": null,\n        \"_pendingEncoding\": \"\",\n        \"server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"_server\": {\n          \"_events\": {\n            \"request\": function(req, res, next) {\\n    app.handle(req, res, next);\\n  },\n            \"connection\": function connectionListener(socket) {\\n  defaultTriggerAsyncIdScope(\\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket\\n  );\\n}\n          },\n          \"_eventsCount\": 2,\n          \"_connections\": 2,\n          \"_handle\": {\n            \"reading\": false,\n            \"onconnection\": function onconnection(err, clientHandle) {\\n  const handle = this;\\n  const self = handle[owner_symbol];\\n\\n  debug('onconnection');\\n\\n  if (err) {\\n    self.emit('error', errnoException(err, 'accept'));\\n    return;\\n  }\\n\\n  if (self.maxConnections && self._connections >= self.maxConnections) {\\n    clientHandle.close();\\n    return;\\n  }\\n\\n  const socket = new Socket({\\n    handle: clientHandle,\\n    allowHalfOpen: self.allowHalfOpen,\\n    pauseOnCreate: self.pauseOnConnect,\\n    readable: true,\\n    writable: true\\n  });\\n\\n  self._connections++;\\n  socket.server = self;\\n  socket._server = self;\\n\\n  DTRACE_NET_SERVER_CONNECTION(socket);\\n  self.emit('connection', socket);\\n}\n          },\n          \"_usingWorkers\": false,\n          \"_workers\": [],\n          \"_unref\": false,\n          \"allowHalfOpen\": true,\n          \"pauseOnConnect\": false,\n          \"httpAllowHalfOpen\": false,\n          \"timeout\": 0,\n          \"keepAliveTimeout\": 5000,\n          \"maxHeadersCount\": null,\n          \"headersTimeout\": 60000,\n          \"requestTimeout\": 0,\n          \"_connectionKey\": \"6::::3000\"\n        },\n        \"parser\": {\n          \"0\": function () { [native code] },\n          \"1\": function parserOnHeaders(headers, url) {\\n  // Once we exceeded headers limit - stop collecting them\\n  if (this.maxHeaderPairs <= 0 ||\\n      this._headers.length < this.maxHeaderPairs) {\\n    this._headers = this._headers.concat(headers);\\n  }\\n  this._url += url;\\n},\n          \"2\": function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,\\n                                 url, statusCode, statusMessage, upgrade,\\n                                 shouldKeepAlive) {\\n  const parser = this;\\n  const { socket } = parser;\\n\\n  if (headers === undefined) {\\n    headers = parser._headers;\\n    parser._headers = [];\\n  }\\n\\n  if (url === undefined) {\\n    url = parser._url;\\n    parser._url = '';\\n  }\\n\\n  // Parser is also used by http client\\n  const ParserIncomingMessage = (socket && socket.server &&\\n                                 socket.server[kIncomingMessage]) ||\\n                                 IncomingMessage;\\n\\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\\n  incoming.httpVersionMajor = versionMajor;\\n  incoming.httpVersionMinor = versionMinor;\\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\\n  incoming.url = url;\\n  incoming.upgrade = upgrade;\\n\\n  if (socket) {\\n    debug('requestTimeout timer moved to req');\\n    incoming[kRequestTimeout] = incoming.socket[kRequestTimeout];\\n    incoming.socket[kRequestTimeout] = undefined;\\n  }\\n\\n  let n = headers.length;\\n\\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\\n  if (parser.maxHeaderPairs > 0)\\n    n = MathMin(n, parser.maxHeaderPairs);\\n\\n  incoming._addHeaderLines(headers, n);\\n\\n  if (typeof method === 'number') {\\n    // server only\\n    incoming.method = methods[method];\\n  } else {\\n    // client only\\n    incoming.statusCode = statusCode;\\n    incoming.statusMessage = statusMessage;\\n  }\\n\\n  return parser.onIncoming(incoming, shouldKeepAlive);\\n},\n          \"3\": function parserOnBody(b, start, len) {\\n  const stream = this.incoming;\\n\\n  // If the stream has already been removed, then drop it.\\n  if (stream === null)\\n    return;\\n\\n  // Pretend this was the result of a stream._read call.\\n  if (len > 0 && !stream._dumped) {\\n    const slice = b.slice(start, start + len);\\n    const ret = stream.push(slice);\\n    if (!ret)\\n      readStop(this.socket);\\n  }\\n},\n          \"4\": function parserOnMessageComplete() {\\n  const parser = this;\\n  const stream = parser.incoming;\\n\\n  if (stream !== null) {\\n    stream.complete = true;\\n    // Emit any trailing headers.\\n    const headers = parser._headers;\\n    if (headers.length) {\\n      stream._addHeaderLines(headers, headers.length);\\n      parser._headers = [];\\n      parser._url = '';\\n    }\\n\\n    // For emit end event\\n    stream.push(null);\\n  }\\n\\n  // Force to read the next incoming message\\n  readStart(parser.socket);\\n},\n          \"5\": function () { [native code] },\n          \"6\": function () { [native code] },\n          \"_headers\": [],\n          \"_url\": \"\",\n          \"socket\": \"[Circular ~.res.req.client]\",\n          \"incoming\": \"[Circular ~.res.req]\",\n          \"outgoing\": null,\n          \"maxHeaderPairs\": 2000,\n          \"_consumed\": true,\n          \"onIncoming\": function () { [native code] }\n        },\n        \"on\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"addListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"prependListener\": function socketListenerWrap(ev, fn) {\\n    const res = net.Socket.prototype[originalFnName].call(this, ev, fn);\\n    if (!this.parser) {\\n      this.on = net.Socket.prototype.on;\\n      this.addListener = net.Socket.prototype.addListener;\\n      this.prependListener = net.Socket.prototype.prependListener;\\n      return res;\\n    }\\n\\n    if (ev === 'data' || ev === 'readable')\\n      unconsume(this.parser, this);\\n\\n    return res;\\n  },\n        \"_paused\": false,\n        \"_httpMessage\": \"[Circular ~.res]\",\n        \"_peername\": {\n          \"address\": \"::1\",\n          \"family\": \"IPv6\",\n          \"port\": 34172\n        },\n        \"timeout\": 0\n      },\n      \"_consuming\": false,\n      \"_dumped\": false,\n      \"next\": function next(err) {\\n    var layerError = err === 'route'\\n      ? null\\n      : err;\\n\\n    // remove added slash\\n    if (slashAdded) {\\n      req.url = req.url.substr(1);\\n      slashAdded = false;\\n    }\\n\\n    // restore altered req.url\\n    if (removed.length !== 0) {\\n      req.baseUrl = parentUrl;\\n      req.url = protohost + removed + req.url.substr(protohost.length);\\n      removed = '';\\n    }\\n\\n    // signal to exit router\\n    if (layerError === 'router') {\\n      setImmediate(done, null)\\n      return\\n    }\\n\\n    // no more matching layers\\n    if (idx >= stack.length) {\\n      setImmediate(done, layerError);\\n      return;\\n    }\\n\\n    // get pathname of request\\n    var path = getPathname(req);\\n\\n    if (path == null) {\\n      return done(layerError);\\n    }\\n\\n    // find next matching layer\\n    var layer;\\n    var match;\\n    var route;\\n\\n    while (match !== true && idx < stack.length) {\\n      layer = stack[idx++];\\n      match = matchLayer(layer, path);\\n      route = layer.route;\\n\\n      if (typeof match !== 'boolean') {\\n        // hold on to layerError\\n        layerError = layerError || match;\\n      }\\n\\n      if (match !== true) {\\n        continue;\\n      }\\n\\n      if (!route) {\\n        // process non-route handlers normally\\n        continue;\\n      }\\n\\n      if (layerError) {\\n        // routes do not match with a pending error\\n        match = false;\\n        continue;\\n      }\\n\\n      var method = req.method;\\n      var has_method = route._handles_method(method);\\n\\n      // build up automatic options response\\n      if (!has_method && method === 'OPTIONS') {\\n        appendMethods(options, route._options());\\n      }\\n\\n      // don't even bother matching route\\n      if (!has_method && method !== 'HEAD') {\\n        match = false;\\n        continue;\\n      }\\n    }\\n\\n    // no match\\n    if (match !== true) {\\n      return done(layerError);\\n    }\\n\\n    // store route for dispatch on change\\n    if (route) {\\n      req.route = route;\\n    }\\n\\n    // Capture one-time layer values\\n    req.params = self.mergeParams\\n      ? mergeParams(layer.params, parentParams)\\n      : layer.params;\\n    var layerPath = layer.path;\\n\\n    // this should be done for the layer\\n    self.process_params(layer, paramcalled, req, res, function (err) {\\n      if (err) {\\n        return next(layerError || err);\\n      }\\n\\n      if (route) {\\n        return layer.handle_request(req, res, next);\\n      }\\n\\n      trim_prefix(layer, layerError, layerPath, path);\\n    });\\n  },\n      \"baseUrl\": \"\",\n      \"originalUrl\": \"/favicon.ico\",\n      \"_parsedUrl\": {\n        \"protocol\": null,\n        \"slashes\": null,\n        \"auth\": null,\n        \"host\": null,\n        \"port\": null,\n        \"hostname\": null,\n        \"hash\": null,\n        \"search\": null,\n        \"query\": null,\n        \"pathname\": \"/favicon.ico\",\n        \"path\": \"/favicon.ico\",\n        \"href\": \"/favicon.ico\",\n        \"_raw\": \"/favicon.ico\"\n      },\n      \"params\": {},\n      \"query\": {},\n      \"res\": \"[Circular ~.res]\",\n      \"body\": {},\n      \"_startAt\": [\n        118812,\n        478117665\n      ],\n      \"_startTime\": \"2020-11-30T04:24:05.279Z\",\n      \"_remoteAddress\": \"::1\"\n    },\n    \"locals\": {},\n    \"writeHead\": function writeHead (statusCode) {\\n    // set headers from arguments\\n    var args = setWriteHeadHeaders.apply(this, arguments)\\n\\n    // fire listener\\n    if (!fired) {\\n      fired = true\\n      listener.call(this)\\n\\n      // pass-along an updated status code\\n      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {\\n        args[0] = this.statusCode\\n        args.length = 1\\n      }\\n    }\\n\\n    return prevWriteHead.apply(this, args)\\n  },\n    \"__onFinished\": function listener(err) {\\n    if (msg.__onFinished === listener) msg.__onFinished = null\\n    if (!listener.queue) return\\n\\n    var queue = listener.queue\\n    listener.queue = null\\n\\n    for (var i = 0; i < queue.length; i++) {\\n      queue[i](err, msg)\\n    }\\n  },\n    \"flush\": function flush () {\\n      if (stream) {\\n        stream.flush()\\n      }\\n    },\n    \"write\": function write (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        this._implicitHeader()\\n      }\\n\\n      return stream\\n        ? stream.write(toBuffer(chunk, encoding))\\n        : _write.call(this, chunk, encoding)\\n    },\n    \"end\": function end (chunk, encoding) {\\n      if (ended) {\\n        return false\\n      }\\n\\n      if (!this._header) {\\n        // estimate the length\\n        if (!this.getHeader('Content-Length')) {\\n          length = chunkLength(chunk, encoding)\\n        }\\n\\n        this._implicitHeader()\\n      }\\n\\n      if (!stream) {\\n        return _end.call(this, chunk, encoding)\\n      }\\n\\n      // mark ended\\n      ended = true\\n\\n      // write Buffer for Node.js 0.8\\n      return chunk\\n        ? stream.end(toBuffer(chunk, encoding))\\n        : stream.end()\\n    },\n    \"on\": function on (type, listener) {\\n      if (!listeners || type !== 'drain') {\\n        return _on.call(this, type, listener)\\n      }\\n\\n      if (stream) {\\n        return stream.on(type, listener)\\n      }\\n\\n      // buffer listeners for future stream\\n      listeners.push([type, listener])\\n\\n      return this\\n    }\n  },\n  \"body\": {},\n  \"_startAt\": [\n    118812,\n    478117665\n  ],\n  \"_startTime\": \"2020-11-30T04:24:05.279Z\",\n  \"_remoteAddress\": \"::1\",\n  \"statusCode\" \u001b[31m[1]\u001b[0m: null\n}\n\u001b[31m\n[1] \"statusCode\" must be one of [400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 421, 422, 423, 424, 425, 426, 428, 429, 431, 451, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511]\u001b[0m","level":"error","service":"monkey"}
{"message":"ENOENT: no such file or directory, stat '/home/digit/Code/monkey/src/public/favicon.ico'","level":"error","service":"monkey"}
